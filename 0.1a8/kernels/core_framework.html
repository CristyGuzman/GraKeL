

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Core Kernel Framework &mdash; GraKeL 0.1.8 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/_static/css/supplementary.css" type="text/css" />
  <link rel="stylesheet" href="../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../_static/gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../_static/gallery-dataframe.css" type="text/css" />
  <link rel="stylesheet" href="../_static/gallery-rendered-html.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Edge Histogram Kernel" href="edge_histogram.html" />
    <link rel="prev" title="Kernels (between graphs)" href="../kernels.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> GraKeL
          

          
            
            <img src="../_static/logo.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.1.8
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../documentation.html">Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks.html">Benchmarks</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../api.html">GraKeL</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../kernels.html">Kernels (between graphs)</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">Core Kernel Framework</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#core-decomposition">Core Decomposition</a></li>
<li class="toctree-l4"><a class="reference internal" href="#core-kernels">Core Kernels</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bibliography">Bibliography</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="edge_histogram.html">Edge Histogram Kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="graph_hopper.html">Graph Hopper Kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="graphlet_sampling.html">Graphlet Sampling Kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="hadamard_code.html">Hadamard Code Kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="kernel.html">Kernel (general class)</a></li>
<li class="toctree-l3"><a class="reference internal" href="lovasz_theta.html">Lovasz Theta Kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="multiscale_laplacian.html">Multiscale Laplacian Kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="neighborhood_hash.html">Neighborhood Hash Kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="neighborhood_subgraph_pairwise_distance.html">Neighborhood Subgraph Pairwise Distance Kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="odd_sth.html">ODD-STh Kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="propagation.html">Propagation Kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="pyramid_match.html">Pyramid Match Kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="random_walk.html">Random Walk Kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="shortest_path.html">Shortest Path Kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="subgraph_matching.html">Subgraph Matching Kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="svm_theta.html">SVM Theta Kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="vertex_histogram.html">Vertex Histogram Kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="weisfeiler_lehman.html">Weisfeiler Lehman Framework</a></li>
<li class="toctree-l3"><a class="reference internal" href="weisfeiler_lehman_optimal_assignment.html">Weisfeiler-Lehman Optimal Assignment</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../graph_kernel.html">GraphKernel (class)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../graph.html">Graph (class)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../datasets.html">Dataset loading utilities</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../classes.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials.html">Tutorials</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">GraKeL</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../api.html">GraKeL</a> &raquo;</li>
        
          <li><a href="../kernels.html">Kernels (between graphs)</a> &raquo;</li>
        
      <li>Core Kernel Framework</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/kernels/core_framework.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="core-kernel-framework">
<span id="core-framework"></span><h1>Core Kernel Framework<a class="headerlink" href="#core-kernel-framework" title="Permalink to this headline">¶</a></h1>
<p>The core framework is a tool for increasing the expressive power of graph kernels <a class="bibtex reference internal" href="#nikolentzos2018degeneracy" id="id1">[NMLV18]</a>.
The framework is not restricted to graph kernels, but can be applied to any graph comparison algorithm.
It capitalizes on the <span class="math notranslate nohighlight">\(k\)</span>-core decomposition which is capable of uncovering topological and hierarchical properties of graphs.
Specifically, the <span class="math notranslate nohighlight">\(k\)</span>-core decomposition is a powerful tool for network analysis and it is commonly used as a measure of importance and well connectedness for vertices in a broad spectrum of applications.
The notion of <span class="math notranslate nohighlight">\(k\)</span>-core was first introduced by Seidman to study the cohesion of social networks <a class="bibtex reference internal" href="#seidman1983network" id="id2">[Sei83]</a>.
In recent years, the <span class="math notranslate nohighlight">\(k\)</span>-core decomposition has been established as a standard tool in many application domains such as in network visualization <a class="bibtex reference internal" href="#alvarez2006large" id="id3">[AHDallAstaBV06]</a>, in protein function prediction <a class="bibtex reference internal" href="#wuchty2005peeling" id="id4">[WA05]</a> and in graph clustering <a class="bibtex reference internal" href="#giatsidis2014corecluster" id="id5">[GMTV14]</a>.</p>
<div class="section" id="core-decomposition">
<h2>Core Decomposition<a class="headerlink" href="#core-decomposition" title="Permalink to this headline">¶</a></h2>
<p>Let <span class="math notranslate nohighlight">\(G = (V,E)\)</span> be an undirected and unweighted graph.
Let <span class="math notranslate nohighlight">\(n\)</span> and <span class="math notranslate nohighlight">\(m\)</span> denote the number of vertices and number of edges, respectively.
Given a subset of vertices <span class="math notranslate nohighlight">\(S \subseteq V\)</span>, let <span class="math notranslate nohighlight">\(E(S)\)</span> be the set of edges that have both end-points in <span class="math notranslate nohighlight">\(S\)</span>.
Then, <span class="math notranslate nohighlight">\(G'=(S,E(S))\)</span> is the subgraph induced by <span class="math notranslate nohighlight">\(S\)</span>.
We use <span class="math notranslate nohighlight">\(G' \subseteq G\)</span> to denote that <span class="math notranslate nohighlight">\(G'\)</span> is a subgraph of <span class="math notranslate nohighlight">\(G\)</span>.
The degree of a vertex <span class="math notranslate nohighlight">\(v \in S\)</span>, <span class="math notranslate nohighlight">\(d_{G'}(v)\)</span>, is equal to the number of vertices that are adjacent to <span class="math notranslate nohighlight">\(v\)</span> in <span class="math notranslate nohighlight">\(G'\)</span>.
Let <span class="math notranslate nohighlight">\(G\)</span> be a graph and <span class="math notranslate nohighlight">\(G'\)</span> a subgraph of <span class="math notranslate nohighlight">\(G\)</span> induced by a set of vertices <span class="math notranslate nohighlight">\(S\)</span>.
Then, <span class="math notranslate nohighlight">\(G'\)</span> is defined to be a <span class="math notranslate nohighlight">\(k\)</span>-core of <span class="math notranslate nohighlight">\(G\)</span>, denoted by <span class="math notranslate nohighlight">\(C_k\)</span>, if it is a maximal subgraph of <span class="math notranslate nohighlight">\(G\)</span> in which all vertices have degree at least <span class="math notranslate nohighlight">\(k\)</span>.
Hence, if <span class="math notranslate nohighlight">\(G'\)</span> is a <span class="math notranslate nohighlight">\(k\)</span>-core of <span class="math notranslate nohighlight">\(G\)</span>, then <span class="math notranslate nohighlight">\(\forall v \in S\)</span>, <span class="math notranslate nohighlight">\(d_{G'}(v) \geq k\)</span>.
Each <span class="math notranslate nohighlight">\(k\)</span>-core is a unique subgraph of <span class="math notranslate nohighlight">\(G\)</span>, and it is not necessarily connected.
The core number <span class="math notranslate nohighlight">\(c(v)\)</span> of a vertex <span class="math notranslate nohighlight">\(v\)</span> is equal to the highest-order core that <span class="math notranslate nohighlight">\(v\)</span> belongs to.
In other words, <span class="math notranslate nohighlight">\(v\)</span> has core number <span class="math notranslate nohighlight">\(c(v) = k\)</span>, if it belongs to a <span class="math notranslate nohighlight">\(k\)</span>-core but not to a <span class="math notranslate nohighlight">\((k+1)\)</span>-core.
The degeneracy <span class="math notranslate nohighlight">\(\delta^*(G)\)</span> of a graph <span class="math notranslate nohighlight">\(G\)</span> is defined as the maximum <span class="math notranslate nohighlight">\(k\)</span> for which graph <span class="math notranslate nohighlight">\(G\)</span> contains a non-empty <span class="math notranslate nohighlight">\(k\)</span>-core subgraph, <span class="math notranslate nohighlight">\(\delta^*(G) = \max_{v \in V}c(v)\)</span>.
Furthermore, assuming that <span class="math notranslate nohighlight">\(\mathcal{C} = \{  C_0, C_1, \ldots, C_{\delta^*(G)} \}\)</span> is the set of all <span class="math notranslate nohighlight">\(k\)</span>-cores, then <span class="math notranslate nohighlight">\(\mathcal{C}\)</span> forms a nested chain</p>
<div class="math notranslate nohighlight">
\[C_{\delta^*(G)} \subseteq \ldots \subseteq C_1 \subseteq C_0 = G\]</div>
<p>Therefore, the <span class="math notranslate nohighlight">\(k\)</span>-core decomposition is a very useful tool for discovering the hierarchical structure of graphs.
The <span class="math notranslate nohighlight">\(k\)</span>-core decomposition of a graph can be computed in <span class="math notranslate nohighlight">\(\mathcal{O}(n+m)\)</span> time cite{matula1983smallest,batagelj2011fast}.
The underlying idea is that we can obtain the <span class="math notranslate nohighlight">\(i\)</span>-core of a graph if we recursively remove all vertices with degree less than <span class="math notranslate nohighlight">\(i\)</span> and their incident edges from the graph until no other vertex can be removed.</p>
</div>
<div class="section" id="core-kernels">
<h2>Core Kernels<a class="headerlink" href="#core-kernels" title="Permalink to this headline">¶</a></h2>
<p>The <span class="math notranslate nohighlight">\(k\)</span>-core decomposition builds a hierarchy of nested subgraphs, each having stronger connectedness properties compared to the previous ones.
The core framework measures the similarity between the corresponding according to the hierarchy subgraphs and aggregates the results.
Let <span class="math notranslate nohighlight">\(G=(V,E)\)</span> and <span class="math notranslate nohighlight">\(G'=(V',E')\)</span> be two graphs.
Let also <span class="math notranslate nohighlight">\(k\)</span> be any kernel for graphs.
Then, the core variant of the base kernel <span class="math notranslate nohighlight">\(k\)</span> is defined as</p>
<div class="math notranslate nohighlight">
\[k_c(G, G') = k(C_0,C'_0) + k(C_1,C'_1) + \ldots + k(C_{\delta^*_{min}},C'_{\delta^*_{min}})\]</div>
<p>where <span class="math notranslate nohighlight">\(\delta^*_{min}\)</span> is the minimum of the degeneracies of the two graphs, and <span class="math notranslate nohighlight">\(C_0,C_1,\ldots,C_{\delta^*_{min}}\)</span> and <span class="math notranslate nohighlight">\(C'_0,C'_1,\ldots,C'_{\delta^*_{min}}\)</span> are the <span class="math notranslate nohighlight">\(0\)</span>-core, <span class="math notranslate nohighlight">\(1\)</span>-core,:math:<cite>ldots</cite>, <span class="math notranslate nohighlight">\(\delta^*_{min}\)</span>-core subgraphs of <span class="math notranslate nohighlight">\(G\)</span> and <span class="math notranslate nohighlight">\(G'\)</span>, respectively.
By decomposing graphs into subgraphs of increasing importance, the algorithm is capable of more accurately capturing their underlying structure.</p>
<p>The computational complexity of the core framework depends on the complexity of the base kernel and the degeneracy of the graphs under comparison.
Given a pair of graphs <span class="math notranslate nohighlight">\(G, G'\)</span> and an algorithm <span class="math notranslate nohighlight">\(A\)</span> for comparing the two graphs, let <span class="math notranslate nohighlight">\(\mathcal{O}_A\)</span> be the time complexity of algorithm <span class="math notranslate nohighlight">\(A\)</span>.
Let also <span class="math notranslate nohighlight">\(\delta^*_{min} = \min \big( \delta^*(G),\delta^*(G') \big)\)</span> be the minimum of the degeneracies of the two graphs.
Then, the complexity of computing the core variant of algorithm <span class="math notranslate nohighlight">\(A\)</span> is <span class="math notranslate nohighlight">\(\mathcal{O}_{c}=\delta^*_{min}\mathcal{O}_A\)</span>.
It is well-known that the degeneracy of a graph is upper bounded by the maximum of the degrees of its vertices and by the largest eigenvalue of its adjacency matrix <span class="math notranslate nohighlight">\(\lambda_1\)</span>.
Since in most real-world graphs it holds that <span class="math notranslate nohighlight">\(\lambda_1 \ll n\)</span>, it also holds that <span class="math notranslate nohighlight">\(\delta^*_{max} \ll n\)</span>, and hence, the time complexity added by the core framework is not very high.</p>
<p>The implementation of the core framework can be found below</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="../generated/grakel.CoreFramework.html#grakel.CoreFramework" title="grakel.CoreFramework"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CoreFramework</span></code></a>([n_jobs, verbose, normalize, …])</p></td>
<td><p>The core kernel framework, as proposed in <a class="bibtex reference internal" href="#nikolentzos2018degeneracy" id="id6">[NMLV18]</a>.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="bibliography">
<h2>Bibliography<a class="headerlink" href="#bibliography" title="Permalink to this headline">¶</a></h2>
<p id="bibtex-bibliography-kernels/core_framework-0"><dl class="citation">
<dt class="bibtex label" id="alvarez2006large"><span class="brackets"><a class="fn-backref" href="#id3">AHDallAstaBV06</a></span></dt>
<dd><p>J. Ignacio Alvarez-Hamelin, Luca Dall’Asta, Alain Barrat, and Alessandro Vespignani. Large scale networks fingerprinting and visualization using the k-core decomposition. <em>Advances in Neural Information Processing Systems</em>, 18:41–50, 2006.</p>
</dd>
<dt class="bibtex label" id="giatsidis2014corecluster"><span class="brackets"><a class="fn-backref" href="#id5">GMTV14</a></span></dt>
<dd><p>Christos Giatsidis, Fragkiskos Malliaros, Dimitrios Thilikos, and Michalis Vazirgiannis. CORECLUSTER: A Degeneracy Based Graph Clustering Framework. In <em>Proceedings of the 28th AAAI Conference on Artificial Intelligence</em>, 44–50. 2014.</p>
</dd>
<dt class="bibtex label" id="nikolentzos2018degeneracy"><span class="brackets">NMLV18</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id6">2</a>)</span></dt>
<dd><p>Giannis Nikolentzos, Polykarpos Meladianos, Stratis Limnios, and Michalis Vazirgiannis. A Degeneracy Framework for Graph Similarity. In <em>27th International Joint Conference on Artificial Intelligence</em>. 2018.</p>
</dd>
<dt class="bibtex label" id="seidman1983network"><span class="brackets"><a class="fn-backref" href="#id2">Sei83</a></span></dt>
<dd><p>Stephen B. Seidman. Network Structure and Minimum Degree. <em>Social networks</em>, 5(3):269–287, 1983.</p>
</dd>
<dt class="bibtex label" id="wuchty2005peeling"><span class="brackets"><a class="fn-backref" href="#id4">WA05</a></span></dt>
<dd><p>Stefan Wuchty and Eivind Almaas. Peeling the yeast protein network. <em>Proteomics</em>, 5(2):444–449, 2005.</p>
</dd>
</dl>
</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="edge_histogram.html" class="btn btn-neutral float-right" title="Edge Histogram Kernel" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="../kernels.html" class="btn btn-neutral float-left" title="Kernels (between graphs)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2019, DaSciM (BSD License).

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>