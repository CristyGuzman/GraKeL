

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Core Concepts &mdash; GraKeL 0.1.8 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/_static/css/supplementary.css" type="text/css" />
  <link rel="stylesheet" href="../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../_static/gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../_static/gallery-dataframe.css" type="text/css" />
  <link rel="stylesheet" href="../_static/gallery-rendered-html.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Creating your Own Kernel" href="creating_kernels.html" />
    <link rel="prev" title="A Short Introduction" href="introduction.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> GraKeL
          

          
            
            <img src="../_static/logo.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.1.8
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../documentation.html">Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="installation.html">Installing GraKeL</a></li>
<li class="toctree-l2"><a class="reference internal" href="introduction.html">A Short Introduction</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Core Concepts</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#what-is-the-grakel-graphkernel-class">What is the <code class="xref py py-class docutils literal notranslate"><span class="pre">grakel.GraphKernel</span></code> Class?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-grakel-kernel-class">The <code class="xref py py-class docutils literal notranslate"><span class="pre">grakel.Kernel</span></code> class</a></li>
<li class="toctree-l3"><a class="reference internal" href="#why-not-a-more-advanced-graph-representation">Why Not a More Advanced Graph Representation?</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="creating_kernels.html">Creating your Own Kernel</a></li>
<li class="toctree-l2"><a class="reference internal" href="contributing.html">Contributing</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks.html">Benchmarks</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../api.html">GraKeL</a></li>
<li class="toctree-l1"><a class="reference internal" href="../classes.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials.html">Tutorials</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">GraKeL</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../documentation.html">Documentation</a> &raquo;</li>
        
      <li>Core Concepts</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/documentation/core_concepts.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="core-concepts">
<span id="id1"></span><h1>Core Concepts<a class="headerlink" href="#core-concepts" title="Permalink to this headline">Â¶</a></h1>
<p><em>GraKeL</em> is organized as shown in the Figure below.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/grakel_schema.svg"><img alt="../_images/grakel_schema.svg" height="411" src="../_images/grakel_schema.svg" width="748" /></a>
</div>
<p>Specifically, the package consists of two subpackages:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../datasets.html#module-grakel.datasets" title="grakel.datasets"><code class="xref py py-class docutils literal notranslate"><span class="pre">grakel.datasets</span></code></a></p></li>
<li><p><a class="reference internal" href="../kernels.html#module-grakel.kernels" title="grakel.kernels"><code class="xref py py-class docutils literal notranslate"><span class="pre">grakel.kernels</span></code></a></p></li>
</ul>
<p>The <a class="reference internal" href="../datasets.html#module-grakel.datasets" title="grakel.datasets"><code class="xref py py-class docutils literal notranslate"><span class="pre">grakel.datasets</span></code></a> subpackage contains functions for automatically downloading graph datasets. On the other hand, the <a class="reference internal" href="../kernels.html#module-grakel.kernels" title="grakel.kernels"><code class="xref py py-class docutils literal notranslate"><span class="pre">grakel.kernels</span></code></a> subpackage contains the <a class="reference internal" href="../generated/grakel.Kernel.html#grakel.Kernel" title="grakel.Kernel"><code class="xref py py-class docutils literal notranslate"><span class="pre">grakel.Kernel</span></code></a> class, and the implementations of all graph kernels and frameworks. Note that all graph kernels and frameworks such as the <a class="reference internal" href="../generated/grakel.ShortestPath.html#grakel.ShortestPath" title="grakel.ShortestPath"><code class="xref py py-class docutils literal notranslate"><span class="pre">grakel.ShortestPath</span></code></a> kernel or the <a class="reference internal" href="../generated/grakel.WeisfeilerLehman.html#grakel.WeisfeilerLehman" title="grakel.WeisfeilerLehman"><code class="xref py py-class docutils literal notranslate"><span class="pre">grakel.WeisfeilerLehman</span></code></a> framework inherit from the <a class="reference internal" href="../generated/grakel.Kernel.html#grakel.Kernel" title="grakel.Kernel"><code class="xref py py-class docutils literal notranslate"><span class="pre">grakel.Kernel</span></code></a> class.</p>
<p>GraKeL also contains the following two classes:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../generated/grakel.Graph.html#grakel.Graph" title="grakel.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">grakel.Graph</span></code></a></p></li>
<li><p><a class="reference internal" href="../generated/grakel.GraphKernel.html#grakel.GraphKernel" title="grakel.GraphKernel"><code class="xref py py-class docutils literal notranslate"><span class="pre">grakel.GraphKernel</span></code></a></p></li>
</ul>
<p>The <a class="reference internal" href="../generated/grakel.Graph.html#grakel.Graph" title="grakel.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">grakel.Graph</span></code></a> class is used to represent graphs and also provides functions for manipulating them. The <a class="reference internal" href="../generated/grakel.GraphKernel.html#grakel.GraphKernel" title="grakel.GraphKernel"><code class="xref py py-class docutils literal notranslate"><span class="pre">grakel.GraphKernel</span></code></a> class is a generic wrapper. This class provides a uniform interface for all the implemented graph kernels and frameworks.</p>
<p>We next present some core components of <em>GraKeL</em>.</p>
<div class="section" id="what-is-the-grakel-graphkernel-class">
<h2>What is the <a class="reference internal" href="../generated/grakel.GraphKernel.html#grakel.GraphKernel" title="grakel.GraphKernel"><code class="xref py py-class docutils literal notranslate"><span class="pre">grakel.GraphKernel</span></code></a> Class?<a class="headerlink" href="#what-is-the-grakel-graphkernel-class" title="Permalink to this headline">Â¶</a></h2>
<p>The <a class="reference internal" href="../generated/grakel.GraphKernel.html#grakel.GraphKernel" title="grakel.GraphKernel"><code class="xref py py-class docutils literal notranslate"><span class="pre">grakel.GraphKernel</span></code></a> class is a <em>generic wrapper class</em>. This class provides a uniform interface for all the implemented graph kernels and frameworks. A graph kernel can be described by an instance of this class, and it holds the attributes listed below:</p>
<ul>
<li><dl>
<dt><code class="code docutils literal notranslate"><span class="pre">kernel</span></code><span class="classifier">Specifies the graph kernel to be computed. It can be either a <code class="code docutils literal notranslate"><span class="pre">base_graph_kernel</span></code> or a list that contains one or more <code class="code docutils literal notranslate"><span class="pre">framework</span></code> along with exactly one <code class="code docutils literal notranslate"><span class="pre">base_graph_kernel</span></code>. The <code class="code docutils literal notranslate"><span class="pre">base_graph_kernel</span></code> needs to be the last element in the list.</span></dt><dd><ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">base_graph_kernel</span></code> : Î <code class="code docutils literal notranslate"><span class="pre">base_graph_kernel</span></code> is a kernel that compares graphs to each other. It is represented by a dictionary which contains a key <code class="code docutils literal notranslate"><span class="pre">'name'</span></code> whose value  corresponds to the name of the kernel. The dictionary can also contain other keys that specify the parameters of the kernel and their values. For instance, we can initialize a shortest path kernel as follows.</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">grakel</span> <span class="kn">import</span> <span class="n">GraphKernel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span> <span class="o">=</span> <span class="n">GraphKernel</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;shortest_path&quot;</span><span class="p">,</span> <span class="s2">&quot;with_labels&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">})</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">framework</span></code> : A <code class="code docutils literal notranslate"><span class="pre">framework</span></code> works on top of graph kernels. It takes a <code class="code docutils literal notranslate"><span class="pre">base_graph_kernel</span></code> as input. Frameworks correspond to dictionaries that contain their name as the value of the key <code class="code docutils literal notranslate"><span class="pre">'name'</span></code>, and their parameters. A <code class="code docutils literal notranslate"><span class="pre">framework</span></code> combined with a <code class="code docutils literal notranslate"><span class="pre">base_graph_kernel</span></code> corresponds to a <code class="code docutils literal notranslate"><span class="pre">base_graph_kernel</span></code> and can be passed on to another <code class="code docutils literal notranslate"><span class="pre">framework</span></code>. For example, a kernel that applies the Weisfeiler-Lehman framework on top of the shortest path kernel is initialized as follows.</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">grakel</span> <span class="kn">import</span> <span class="n">GraphKernel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span> <span class="o">=</span> <span class="n">GraphKernel</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="p">[{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;weisfeiler_lehman&quot;</span><span class="p">,</span> <span class="s2">&quot;n_iter&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">},</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;shortest_path&quot;</span><span class="p">}])</span>
</pre></div>
</div>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="code docutils literal notranslate"><span class="pre">normalize</span></code><span class="classifier">A kernel can provide either an unnormalized or a normalized output.</span></dt><dd><p>The normalized kernel value between two graphs <span class="math notranslate nohighlight">\(G_1\)</span> and <span class="math notranslate nohighlight">\(G_2\)</span> is computed as follows: <span class="math notranslate nohighlight">\(k(G_1, G_2)/\sqrt{k(G_1, G_1) k(G_2, G_2)}\)</span>. This normalization ensures that the kernel value between a graph and itself is equal to 1, while the kernel value between a graph and any other graph takes values between 0 and 1.</p>
<div class="line-block">
<div class="line"><strong>Example</strong></div>
</div>
<p>Suppose we have a set of training graphs <code class="code docutils literal notranslate"><span class="pre">G_train</span></code>, and a set of test graphs <code class="code docutils literal notranslate"><span class="pre">G_test</span></code>. We compute the normalized kernel matrices using the Weisfeiler-Lehman subtree kernel as follows.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span> <span class="o">=</span> <span class="n">GraphKernel</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="p">[{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;weisfeiler_lehman&quot;</span><span class="p">,</span> <span class="s2">&quot;n_iter&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">},</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;subtree_wl&quot;</span><span class="p">}],</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Calculate the normalized kernel matrices</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K_train</span> <span class="o">=</span> <span class="n">gk</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">G_train</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K_test</span> <span class="o">=</span> <span class="n">gk</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">G_test</span><span class="p">)</span>
</pre></div>
</div>
<p>The above is equivalent (for deterministic kernels) to the code below.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span> <span class="o">=</span> <span class="n">GraphKernel</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="p">[{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;weisfeiler_lehman&quot;</span><span class="p">,</span> <span class="s2">&quot;n_iter&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">},</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;subtree_wl&quot;</span><span class="p">}],</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span> <span class="o">=</span> <span class="n">gk</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K_diag</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K_train_diag</span><span class="p">,</span> <span class="n">K_test_diag</span> <span class="o">=</span> <span class="n">K_diag</span><span class="p">[</span><span class="n">idx_train</span><span class="p">],</span> <span class="n">K_diag</span><span class="p">[</span><span class="n">idx_test</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Calculate the normalized kernel matrices</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K_train</span> <span class="o">=</span> <span class="n">K</span><span class="p">[</span><span class="n">idx_train</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">idx_train</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">K_train_diag</span><span class="p">,</span> <span class="n">K_train_diag</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K_test</span> <span class="o">=</span> <span class="n">K</span><span class="p">[</span><span class="n">idx_test</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">idx_train</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">K_test_diag</span><span class="p">,</span> <span class="n">K_train_diag</span><span class="p">))</span>
</pre></div>
</div>
<p>Note that in the second case, we perform more computations since we also compare the graphs of the test set to each other.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="code docutils literal notranslate"><span class="pre">Nystroem</span></code><span class="classifier">The NystrÃ¶m method is a well-established approach for approximating kernel matrices on large datasets.</span></dt><dd><p>If <span class="math notranslate nohighlight">\(n\)</span> is the number of samples, computing and storing the kernel matrix requires <span class="math notranslate nohighlight">\(\mathcal{O}(n^2)\)</span> time and memory, respectively. Therefore, applying kernel methods will become unfeasible when <span class="math notranslate nohighlight">\(n\)</span> is large. The NystrÃ¶m approximation can allow a significant speed-up of the calculations by computing an approximation <span class="math notranslate nohighlight">\(\tilde{\mathbf{K}}\)</span> of rank <span class="math notranslate nohighlight">\(q\)</span> of the kernel matrix. The method uses a subset of the training data as basis and reduces the storage and complexity requirements to <span class="math notranslate nohighlight">\(\mathcal{O}(n q)\)</span>. The value of <span class="math notranslate nohighlight">\(q\)</span> is specified by the user by setting <code class="code docutils literal notranslate"><span class="pre">Nystroem</span></code> equal to an integer value. An example demonstrating the power of the NystrÃ¶m method is given below.</p>
<div class="line-block">
<div class="line"><strong>Example</strong></div>
</div>
<p>We first download the MUTAG dataset and split it into a training and a test set.</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">grakel.datasets</span> <span class="kn">import</span> <span class="n">fetch_dataset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MUTAG</span> <span class="o">=</span> <span class="n">fetch_dataset</span><span class="p">(</span><span class="s2">&quot;MUTAG&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">MUTAG</span><span class="o">.</span><span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">MUTAG</span><span class="o">.</span><span class="n">target</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G_train</span><span class="p">,</span> <span class="n">G_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
</pre></div>
</div>
<p>We next initialize a Weisfeiler-Lehman subtree kernel using <code class="code docutils literal notranslate"><span class="pre">GraphKernel</span></code>, and we also make use of <code class="code docutils literal notranslate"><span class="pre">Nystroem</span></code> with <span class="math notranslate nohighlight">\(q=20\)</span> to approximate the kernel matrix.</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">grakel</span> <span class="kn">import</span> <span class="n">GraphKernel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span> <span class="o">=</span> <span class="n">GraphKernel</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="p">[{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;weisfeiler_lehman&quot;</span><span class="p">,</span> <span class="s2">&quot;n_iter&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">},</span> <span class="s2">&quot;subtree_wl&quot;</span><span class="p">],</span> <span class="n">Nystroem</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K_train</span> <span class="o">=</span> <span class="n">gk</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">G_train</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K_test</span> <span class="o">=</span> <span class="n">gk</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">G_test</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">K_train</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(169, 20)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">K_test</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(19, 20)</span>
</pre></div>
</div>
<p>Then, we train a standard SVM classifier with linear kernel, and use the classifier to make predictions.</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">SVC</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">SVC</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">K_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="go">SVC(kernel=&#39;linear&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">K_test</span><span class="p">)</span>
</pre></div>
</div>
<p>Finally, we calculate the classification accuracy.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">accuracy_score</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">accuracy_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span> <span class="s2">&quot;%&quot;</span><span class="p">)</span>
<span class="go">94.74 %</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<div class="line-block">
<div class="line">To compute the full kernel matrices, we needed to perform <span class="math notranslate nohighlight">\(~ 169 * (169-1) /2 + 19 * 169 = 17,407\)</span> kernel computations. Instead, we performed <span class="math notranslate nohighlight">\(~ 20 * (20-1)/ 2 + 20 * 169 + 20* 19 = 3,950\)</span> kernel computations. As we can see, the approximation also led to an increase in performance.</div>
</div>
</div>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="code docutils literal notranslate"><span class="pre">n_jobs</span></code><span class="classifier">Some kernels consist of operations that can be executed in parallel, leading to a reduction in the running time.</span></dt><dd><p>The <code class="code docutils literal notranslate"><span class="pre">n_jobs</span></code> attribute has the same functionality as that of scikit-learn. It determines the number of jobs that will run in parallel. If <code class="code docutils literal notranslate"><span class="pre">n_jobs</span></code> is set equal to -1, all the processors will be utilized. Note that this attribute will not have an impact on the computation of some kernels whose code is not parallelized. These kernels either take advantage of the parallelization inherent in other libraries (e.g., NumPy) or their code is only partially parallelizable or not parallelizable at all. In such scenarios, a warning is issued.</p>
<p>If you are interested in parallelizing any of the implemented kernels, you can <em>contribute</em> to the <em>GraKeL</em> project. To find out how you can contribute, please have a look at <a class="reference internal" href="contributing.html#contributing"><span class="std std-ref">Contributing</span></a>.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="code docutils literal notranslate"><span class="pre">random_state</span></code><span class="classifier">This attribute is used for initializing the internal random number generator.</span></dt><dd><p>It has no effect on deterministic graph kernels, but only on kernels that involve some random process (e.g., those that perform sampling). It also applies to the <code class="code docutils literal notranslate"><span class="pre">Nystroem</span></code> function of the <code class="code docutils literal notranslate"><span class="pre">GraphKernel</span></code> class which also performs sampling. If int, <code class="code docutils literal notranslate"><span class="pre">random_state</span></code> is the seed used by the random number generator. Otherwise, it can be a <code class="code docutils literal notranslate"><span class="pre">RandomState</span></code> instance. If <code class="code docutils literal notranslate"><span class="pre">None</span></code>, the random number generator is the <code class="code docutils literal notranslate"><span class="pre">RandomState</span></code> instance used by <code class="code docutils literal notranslate"><span class="pre">np.random</span></code>. The use of <code class="code docutils literal notranslate"><span class="pre">random_state</span></code> is illustrated in the following example.</p>
<div class="line-block">
<div class="line"><strong>Example</strong></div>
</div>
<p>We first create the graph representations of the following two molecules: (1) water <span class="math notranslate nohighlight">\(\mathbf{H}_{2}\mathbf{O}\)</span> and (2) hydronium <span class="math notranslate nohighlight">\(\mathbf{H}_{3}\mathbf{O}^{+}\)</span>, an ion of water produced by protonation.</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">grakel</span> <span class="kn">import</span> <span class="n">Graph</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H2O_adjacency</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H2O_node_labels</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s1">&#39;O&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H2O</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">initialization_object</span><span class="o">=</span><span class="n">H2O_adjacency</span><span class="p">,</span> <span class="n">node_labels</span><span class="o">=</span><span class="n">H2O_node_labels</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H3O_adjacency</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H3O_node_labels</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s1">&#39;O&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="s1">&#39;H&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H3O</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">initialization_object</span><span class="o">=</span><span class="n">H3O_adjacency</span><span class="p">,</span> <span class="n">node_labels</span><span class="o">=</span><span class="n">H3O_node_labels</span><span class="p">)</span>
</pre></div>
</div>
<p>We will then compute the <em>graphlet kernel</em> between the two molecules. The graphlet kernel counts the number of common graphlets (i.e., small subgraphs) in two graphs. Instead of exaustively enumerating all the graphlets, it usually samples a number of them. In this example, we will sample 5 graphlets from each graph.</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">grakel</span> <span class="kn">import</span> <span class="n">GraphKernel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span> <span class="o">=</span> <span class="n">GraphKernel</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;graphlet_sampling&quot;</span><span class="p">,</span> <span class="n">sampling</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">5</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span><span class="o">.</span><span class="n">fit</span><span class="p">([</span><span class="n">H2O</span><span class="p">])</span>
<span class="go">GraphKernel(kernel={&#39;name&#39;: &#39;graphlet_sampling&#39;, &#39;sampling&#39;: {&#39;n_samples&#39;: 5}})</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span><span class="o">.</span><span class="n">transform</span><span class="p">([</span><span class="n">H3O</span><span class="p">])</span>
<span class="go">array([[10.]])</span>
</pre></div>
</div>
<p>Note that we did not set <code class="code docutils literal notranslate"><span class="pre">random_state</span></code> to some value, and therefore it took its default <code class="code docutils literal notranslate"><span class="pre">None</span></code> value. We will now set <code class="code docutils literal notranslate"><span class="pre">random_state</span></code> equal to 42.</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span> <span class="o">=</span> <span class="n">GraphKernel</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;graphlet_sampling&quot;</span><span class="p">,</span> <span class="n">sampling</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">5</span><span class="p">),</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">20</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span><span class="o">.</span><span class="n">fit</span><span class="p">([</span><span class="n">H2O</span><span class="p">])</span>
<span class="go">GraphKernel(kernel={&#39;name&#39;: &#39;graphlet_sampling&#39;, &#39;random_state&#39;: 20,</span>
<span class="go">                    &#39;sampling&#39;: {&#39;n_samples&#39;: 5}})</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span><span class="o">.</span><span class="n">transform</span><span class="p">([</span><span class="n">H3O</span><span class="p">])</span>
<span class="go">array([[20.]])</span>
</pre></div>
</div>
<p>As you can see, the new kernel value is not equal to the previous one. If we re-run the above code, we will obtain the same kernel value since the algorithm will sample exactly the same graphlets from both graphs. As shown below, we can also obtain the same kernel value if <code class="code docutils literal notranslate"><span class="pre">random_state</span></code> is initialized as an attribute of <code class="code docutils literal notranslate"><span class="pre">GraphKernel</span></code> instead of the graphlet kernel itself.</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span> <span class="o">=</span> <span class="n">GraphKernel</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;graphlet_sampling&quot;</span><span class="p">,</span> <span class="n">sampling</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">5</span><span class="p">)),</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span><span class="o">.</span><span class="n">fit</span><span class="p">([</span><span class="n">H2O</span><span class="p">])</span>
<span class="go">GraphKernel(kernel={&#39;name&#39;: &#39;graphlet_sampling&#39;, &#39;sampling&#39;: {&#39;n_samples&#39;: 5}},</span>
<span class="go">            random_state=20)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span><span class="o">.</span><span class="n">transform</span><span class="p">([</span><span class="n">H3O</span><span class="p">])</span>
<span class="go">array([[20.]])</span>
</pre></div>
</div>
<p>If we provide a <code class="code docutils literal notranslate"><span class="pre">random_state</span></code> value to both <code class="code docutils literal notranslate"><span class="pre">GraphKernel</span></code> and <code class="code docutils literal notranslate"><span class="pre">kernel</span></code>, then each one will have an effect only on the corresponding instances.</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span> <span class="o">=</span> <span class="n">GraphKernel</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;graphlet_sampling&quot;</span><span class="p">,</span> <span class="n">sampling</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span><span class="o">.</span><span class="n">fit</span><span class="p">([</span><span class="n">H2O</span><span class="p">])</span>
<span class="go">GraphKernel(kernel={&#39;name&#39;: &#39;graphlet_sampling&#39;,</span>
<span class="go">                    &#39;sampling&#39;: {&#39;n_samples&#39;: 5, &#39;random_state&#39;: 0}},</span>
<span class="go">            random_state=20)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span><span class="o">.</span><span class="n">transform</span><span class="p">([</span><span class="n">H3O</span><span class="p">])</span>
<span class="go">array([[20.]])</span>
</pre></div>
</div>
<p>while</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span> <span class="o">=</span> <span class="n">GraphKernel</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;graphlet_sampling&quot;</span><span class="p">,</span> <span class="n">sampling</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">5</span><span class="p">)),</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span><span class="o">.</span><span class="n">fit</span><span class="p">([</span><span class="n">H2O</span><span class="p">])</span><span class="o">.</span><span class="n">transform</span><span class="p">([</span><span class="n">H3O</span><span class="p">])</span>
<span class="go">array([[10.]])</span>
</pre></div>
</div>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="code docutils literal notranslate"><span class="pre">verbose</span></code><span class="classifier">Currently not supported.</span></dt><dd><div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="code docutils literal notranslate"><span class="pre">verbose</span></code> is an attribute that is currently not supported, but may be supported in the future for printing progress messages.</p>
</div>
</dd>
</dl>
</li>
</ul>
<p>We will next focus on the <a class="reference internal" href="../generated/grakel.Kernel.html#grakel.Kernel" title="grakel.Kernel"><code class="xref py py-class docutils literal notranslate"><span class="pre">grakel.Kernel</span></code></a> class. Instances of this class are wrapped in an instance of the <a class="reference internal" href="../generated/grakel.GraphKernel.html#grakel.GraphKernel" title="grakel.GraphKernel"><code class="xref py py-class docutils literal notranslate"><span class="pre">grakel.GraphKernel</span></code></a> class that was presented above.</p>
</div>
<div class="section" id="the-grakel-kernel-class">
<h2>The <a class="reference internal" href="../generated/grakel.Kernel.html#grakel.Kernel" title="grakel.Kernel"><code class="xref py py-class docutils literal notranslate"><span class="pre">grakel.Kernel</span></code></a> class<a class="headerlink" href="#the-grakel-kernel-class" title="Permalink to this headline">Â¶</a></h2>
<p>All graph kernels inherit from this class.</p>
<p>A graph kernel is a function <span class="math notranslate nohighlight">\(k\)</span> between two graphs. That is, <span class="math notranslate nohighlight">\(k \; : \; \mathcal{G} \times \mathcal{G} \rightarrow \mathbb{R}\)</span> where <span class="math notranslate nohighlight">\(\mathcal{G}\)</span> is the space of graphs. We usually do not have just two graphs, but a large set of graphs, and we are interested to compare these graphs to each other using some kernel. In almost all cases, it is more computationally efficient to compute all the kernel values in one step than computing the kernel value for each pair individaully. Therefore, we designed our kernels to take sets of graphs as input instead of just two graphs.</p>
<p>The <em>GraKeL</em> package had also to be compatible with <em>scikit-learn</em>. From the different scikit-learn structures, the one that fitted best to our setting was the <code class="code docutils literal notranslate"><span class="pre">TransformerMixin</span></code> class, which consists of the following three methods: <code class="code docutils literal notranslate"><span class="pre">fit</span></code>, <code class="code docutils literal notranslate"><span class="pre">fit_transform</span></code> and <code class="code docutils literal notranslate"><span class="pre">transform</span></code>. The three methods are designed to perform the following tasks in our package:</p>
<ul class="simple">
<li><p>The <code class="code docutils literal notranslate"><span class="pre">fit</span></code> method extracts kernel dependent features from an input graph collection.</p></li>
<li><p>The <code class="code docutils literal notranslate"><span class="pre">fit_transform</span></code> method does the same job as <code class="code docutils literal notranslate"><span class="pre">fit</span></code>, but also computes the kernel matrix emerging from the input graph collection.</p></li>
<li><p>The <code class="code docutils literal notranslate"><span class="pre">transform</span></code> method calculates the kernel matrix between a new collection of graphs and the one given as input to <code class="code docutils literal notranslate"><span class="pre">fit</span></code> or to <code class="code docutils literal notranslate"><span class="pre">fit_transform</span></code>.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="code docutils literal notranslate"><span class="pre">fit</span></code> and <code class="code docutils literal notranslate"><span class="pre">fit_transform</span></code> methods usually extract some features from the set of graphs that is given as input. These features are stored into memory and are not modified by the applications of the <code class="code docutils literal notranslate"><span class="pre">transform</span></code> method. This (the need to copy and protect the extracted data) however adds some overhead to the computation of some kernels such as the ODD-STh kernel. In such cases, the user may prefer to use the <code class="code docutils literal notranslate"><span class="pre">fit_transform</span></code> method once and then manually retrieve the two kernel matrices.</p>
</div>
<p>The Figure below illustrates how the <a class="reference internal" href="../generated/grakel.Kernel.html#grakel.Kernel" title="grakel.Kernel"><code class="xref py py-class docutils literal notranslate"><span class="pre">grakel.Kernel</span></code></a> class is organized.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/kernel_schema.svg"><img alt="../_images/kernel_schema.svg" height="571" src="../_images/kernel_schema.svg" width="558" /></a>
</div>
<p>Besides the three methods discussed above, there also exist some other methods as shown in the Figure. As can be seen, these methods are called by the <code class="code docutils literal notranslate"><span class="pre">fit</span></code>, <code class="code docutils literal notranslate"><span class="pre">fit_transform</span></code> and <code class="code docutils literal notranslate"><span class="pre">transform</span></code> methods. The <code class="code docutils literal notranslate"><span class="pre">diagonal</span></code> method is used for normalizing kernel matrices. It returns the self-kernel values of all the graphs given as input to <code class="code docutils literal notranslate"><span class="pre">fit</span></code> along with those given as input to <code class="code docutils literal notranslate"><span class="pre">transform</span></code>, provided that this method has been called. The <code class="code docutils literal notranslate"><span class="pre">parse_input</span></code> method extracts features from the collection of graphs that is given as input either to <code class="code docutils literal notranslate"><span class="pre">fit</span></code> or to <code class="code docutils literal notranslate"><span class="pre">transform</span></code>. The <code class="code docutils literal notranslate"><span class="pre">pairwise_operation</span></code> method computes the kernel between two graphs. This method is used by the <code class="code docutils literal notranslate"><span class="pre">calculate_kernel_matrix</span></code> method which generates kernel matrices from collections of graphs. Finally, the <code class="code docutils literal notranslate"><span class="pre">initialize_</span></code> function is used just for initialization purposes.</p>
<p>A kernel initialized as an instance of the <a class="reference internal" href="../generated/grakel.Kernel.html#grakel.Kernel" title="grakel.Kernel"><code class="xref py py-class docutils literal notranslate"><span class="pre">grakel.Kernel</span></code></a> class is equivalent to an instance of the <a class="reference internal" href="../generated/grakel.GraphKernel.html#grakel.GraphKernel" title="grakel.GraphKernel"><code class="xref py py-class docutils literal notranslate"><span class="pre">grakel.GraphKernel</span></code></a> generic wrapper corresponding to the same kernel if the attributes of the two kernels are identical to each other. To illustrate this, we will employ a deterministic graph kernel (the Wesfeiler-Lehman subtree kernel) and we will investigate if the kernel values produced by the two instances of the kernel are equal to each other.</p>
<p>We first initialize the instance of the <a class="reference internal" href="../generated/grakel.Kernel.html#grakel.Kernel" title="grakel.Kernel"><code class="xref py py-class docutils literal notranslate"><span class="pre">grakel.Kernel</span></code></a> class. This corresponds to the Weisfeiler-Lehman framework on top of the vertex histogram kernel.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">grakel</span> <span class="kn">import</span> <span class="n">WeisfeilerLehman</span><span class="p">,</span> <span class="n">VertexHistogram</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gk_1</span> <span class="o">=</span> <span class="n">WeisfeilerLehman</span><span class="p">(</span><span class="n">n_iter</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">base_graph_kernel</span><span class="o">=</span><span class="n">VertexHistogram</span><span class="p">)</span>
</pre></div>
</div>
<p>We have set the <code class="code docutils literal notranslate"><span class="pre">base_graph_kernel</span></code> attribute equal to the <code class="xref py py-class docutils literal notranslate"><span class="pre">grakel.kernels.VertexHistogram</span></code> class. Note that the <code class="code docutils literal notranslate"><span class="pre">base_graph_kernel</span></code> attribute can also be set equal to a tuple consisting of a <code class="xref py py-class docutils literal notranslate"><span class="pre">grakel.kernel</span></code> class and a dictionary containing the attributes of the corresponding kernel and their values. Above, we have set the attributes of the vertex histogram kernel to their default values. Therefore, the above code is equivalent to the following.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gk_1</span> <span class="o">=</span> <span class="n">WeisfeilerLehman</span><span class="p">(</span><span class="n">n_iter</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">base_graph_kernel</span><span class="o">=</span><span class="p">(</span><span class="n">VertexHistogram</span><span class="p">,</span> <span class="p">{}))</span>
</pre></div>
</div>
<p>We will perform our experiment on the MUTAG dataset.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">grakel.datasets</span> <span class="kn">import</span> <span class="n">fetch_dataset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MUTAG</span> <span class="o">=</span> <span class="n">fetch_dataset</span><span class="p">(</span><span class="s2">&quot;MUTAG&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">MUTAG</span><span class="o">.</span><span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">MUTAG</span><span class="o">.</span><span class="n">target</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K_1</span> <span class="o">=</span> <span class="n">gk_1</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
<p>We will now test if the kernel matrix produced by the instance of the <a class="reference internal" href="../generated/grakel.GraphKernel.html#grakel.GraphKernel" title="grakel.GraphKernel"><code class="xref py py-class docutils literal notranslate"><span class="pre">grakel.GraphKernel</span></code></a> class is equal to the one produced by the instance of the <a class="reference internal" href="../generated/grakel.Kernel.html#grakel.Kernel" title="grakel.Kernel"><code class="xref py py-class docutils literal notranslate"><span class="pre">grakel.Kernel</span></code></a> class.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">grakel</span> <span class="kn">import</span> <span class="n">GraphKernel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">array_equal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gk_2</span> <span class="o">=</span> <span class="n">GraphKernel</span><span class="p">(</span><span class="n">kernel</span> <span class="o">=</span> <span class="p">[{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;weisfeiler_lehman&quot;</span><span class="p">,</span> <span class="s2">&quot;n_iter&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">},</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;subtree_wl&quot;</span><span class="p">}])</span> <span class="c1"># The alias &quot;subtree_wl&quot; is supported inside the generic wrapper</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K_2</span> <span class="o">=</span> <span class="n">gk_2</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">array_equal</span><span class="p">(</span><span class="n">K_1</span><span class="p">,</span> <span class="n">K_2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>As we can see, the two matrices are indeed equal to each other.</p>
</div>
<div class="section" id="why-not-a-more-advanced-graph-representation">
<h2>Why Not a More Advanced Graph Representation?<a class="headerlink" href="#why-not-a-more-advanced-graph-representation" title="Permalink to this headline">Â¶</a></h2>
<p>As already discussed, the graph objects in <em>GraKeL</em> are instances of the <a class="reference internal" href="../generated/grakel.Graph.html#grakel.Graph" title="grakel.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">grakel.Graph</span></code></a> class. The <a class="reference internal" href="../generated/grakel.Graph.html#grakel.Graph" title="grakel.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">grakel.Graph</span></code></a> class is very simple, and this may raise the question why <em>GraKeL</em> does not utilize the graph structures of well-established graph libraries such as <a class="reference external" href="https://networkx.github.io/">networkx</a> and <a class="reference external" href="http://igraph.org/python/">igraph</a>. The answer is that the operations that most kernels perform on graphs are relatively simple and easily implementable. For instance, a kernel may need to retrieve the neighbors of a vertex or to compute the shortest paths between all pairs of nodes. Standard graph libraries provide many more functions, and they are specially designed such that all these functions are computed efficiently. Since <em>GraKeL</em> would only utilize a small fraction of these functions, introducing an extra dependency to some large library seemed not to be a good idea.</p>
<p>We will again experiment with the two molecules: (1) water <span class="math notranslate nohighlight">\(\mathbf{H}_{2}\mathbf{O}\)</span> and (2) hydronium <span class="math notranslate nohighlight">\(\mathbf{H}_{3}\mathbf{O}^{+}\)</span>.</p>
<p>We will first initialize five water molecules using the different edgelist representations and show that they are equivalent to each other.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">grakel</span> <span class="kn">import</span> <span class="n">Graph</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H2Od</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H2Od</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Graph</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mf">1.</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mf">1.</span><span class="p">},</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}}))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H2Od</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Graph</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="s1">&#39;c&#39;</span><span class="p">:[</span><span class="s1">&#39;b&#39;</span><span class="p">]}))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H2Od</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Graph</span><span class="p">({(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">):</span> <span class="mf">1.</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">):</span> <span class="mf">1.</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">):</span> <span class="mf">1.</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">):</span> <span class="mf">1.</span><span class="p">}))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H2Od</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Graph</span><span class="p">([(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H2Od</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Graph</span><span class="p">([(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mf">1.</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mf">1.</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mf">1.</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)]))</span>
</pre></div>
</div>
<p>Then, we compare the first representation against all the other.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">any</span><span class="p">(</span><span class="n">H2Od</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get_edge_dictionary</span><span class="p">()</span> <span class="o">==</span> <span class="n">H2Od</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_edge_dictionary</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Now, we will do the same for the case of the adjacency matrix representations.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">csr_matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H2O</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H2O</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Graph</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H2O</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Graph</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H2O</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Graph</span><span class="p">(</span><span class="n">csr_matrix</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))))</span>
</pre></div>
</div>
<p>Then, we again compare the first representation against all the other.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">array_equal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">all</span><span class="p">(</span><span class="n">array_equal</span><span class="p">(</span><span class="n">H2O</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get_adjacency_matrix</span><span class="p">(),</span> <span class="n">H2O</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_adjacency_matrix</span><span class="p">())</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Next, we will create two instances of the <code class="code docutils literal notranslate"><span class="pre">grakel.Graph</span></code> class, the first using the adjacency_matrix representation and the second using the edgelist representation. We will also assign labels to the nodes and edges of the two graphs. Then, we will show that the two representations are equivalent to each other.</p>
<p>We create the adjacency matrix and use this matrix to create the first object.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H2O_adj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H2O_labels</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s1">&#39;O&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H2O_edge_labels</span> <span class="o">=</span> <span class="p">{(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span> <span class="s1">&#39;pcb&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span> <span class="s1">&#39;pcb&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span> <span class="s1">&#39;pcb&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span> <span class="s1">&#39;pcb&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adj_graph</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">H2O_adj</span><span class="p">,</span> <span class="n">H2O_labels</span><span class="p">,</span> <span class="n">H2O_edge_labels</span><span class="p">,</span> <span class="s2">&quot;all&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>We then create the second graph object.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H2Od_edg</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mf">1.</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mf">1.</span><span class="p">},</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H2Od_labels</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="s1">&#39;O&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H2Od_edge_labels</span> <span class="o">=</span> <span class="p">{(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">):</span> <span class="s1">&#39;pcb&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">):</span> <span class="s1">&#39;pcb&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">):</span> <span class="s1">&#39;pcb&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">):</span> <span class="s1">&#39;pcb&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">edge_dict_graph</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">H2Od_edg</span><span class="p">,</span> <span class="n">H2Od_labels</span><span class="p">,</span> <span class="n">H2Od_edge_labels</span><span class="p">,</span> <span class="s2">&quot;all&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>We test if the adjacency matrices of the two objects are equal to each other.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">array_equal</span><span class="p">(</span><span class="n">adj_graph</span><span class="o">.</span><span class="n">get_adjacency_matrix</span><span class="p">(),</span> <span class="n">edge_dict_graph</span><span class="o">.</span><span class="n">get_adjacency_matrix</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
<p>and</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">adj_graph</span><span class="o">.</span><span class="n">get_edge_dictionary</span><span class="p">()</span> <span class="o">==</span> <span class="n">edge_dict_graph</span><span class="o">.</span><span class="n">get_edge_dictionary</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Finally, we also compare the labels of the nodes and the edges of the two objects.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">all</span><span class="p">((</span><span class="n">adj_graph</span><span class="o">.</span><span class="n">get_labels</span><span class="p">(</span><span class="n">purpose</span><span class="o">=</span><span class="s2">&quot;adjacency&quot;</span><span class="p">,</span> <span class="n">label_type</span><span class="o">=</span><span class="n">lt</span><span class="p">),</span> <span class="n">edge_dict_graph</span><span class="o">.</span><span class="n">get_labels</span><span class="p">(</span><span class="n">purpose</span><span class="o">=</span><span class="s2">&quot;adjacency&quot;</span><span class="p">,</span> <span class="n">label_type</span><span class="o">=</span><span class="n">lt</span><span class="p">))</span> <span class="k">for</span> <span class="n">lt</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;vertex&quot;</span><span class="p">,</span> <span class="s2">&quot;edge&quot;</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Above, we showed that the adjacency matrices of the two objects are equal to each other. The same does not hold for their edge dictionaries (i.e., <code class="code docutils literal notranslate"><span class="pre">edge_dictionary</span></code>) since the adjacency matrix contains no information about the names of the nodes. Note that these names have to be instances of some <strong>sortable</strong> datatype such that indexing can be performed.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The fourth attribute of the constructor of the <code class="code docutils literal notranslate"><span class="pre">grakel.Graph</span></code> class (i.e., <code class="code docutils literal notranslate"><span class="pre">graph_format</span></code>) corresponds to the format into which the graph object will be stored. The default value of this attribute is <code class="code docutils literal notranslate"><span class="pre">&quot;auto&quot;</span></code> which maintains the format that is passed on to the constructor. This attribute can also take the values <code class="code docutils literal notranslate"><span class="pre">&quot;adjacency&quot;</span></code>, <code class="code docutils literal notranslate"><span class="pre">&quot;dictionary&quot;</span></code>, and <code class="code docutils literal notranslate"><span class="pre">all</span></code>. The last value ensures that the <code class="code docutils literal notranslate"><span class="pre">grakel.Graph</span></code> instance will contain both representations and their corresponding node and edge labels. Note that the <code class="code docutils literal notranslate"><span class="pre">get_adjacency_matrix</span></code> and <code class="code docutils literal notranslate"><span class="pre">get_edge_dictionary</span></code> methods create and return the corresponding graph representation if it does not exist. On the other hand, the <code class="code docutils literal notranslate"><span class="pre">get_labels</span></code> method will modify the graph format if the labels are not in the proper format and a warning will also be issued. Note that the user can set the <code class="code docutils literal notranslate"><span class="pre">graph_format</span></code> attribute to some value later on as follows.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">adj_graph</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">H2O_adj</span><span class="p">,</span> <span class="n">H2O_labels</span><span class="p">,</span> <span class="n">H2O_edge_labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adj_graph</span><span class="o">.</span><span class="n">change_format</span><span class="p">(</span><span class="s2">&quot;all&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Alternatively, the user can specify which is his/her desired format, and it will be created if it does not exist.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">adj_graph</span><span class="o">.</span><span class="n">desired_format</span><span class="p">(</span><span class="s2">&quot;dictionary&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>The methods of the graph kernels take lists of <a class="reference internal" href="../generated/grakel.Graph.html#grakel.Graph" title="grakel.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">grakel.Graph</span></code></a> objects as input, extract the necessary features and may return some matrices. It should be mentioned that the <a class="reference internal" href="../generated/grakel.Kernel.html#grakel.Kernel" title="grakel.Kernel"><code class="xref py py-class docutils literal notranslate"><span class="pre">grakel.Kernel</span></code></a> objects are not allowed to modify the graphs that they take as input.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="creating_kernels.html" class="btn btn-neutral float-right" title="Creating your Own Kernel" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="introduction.html" class="btn btn-neutral float-left" title="A Short Introduction" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2019, DaSciM (BSD License).

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>