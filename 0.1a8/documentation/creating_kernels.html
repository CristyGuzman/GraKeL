

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Creating your Own Kernel &mdash; GraKeL 0.1.8 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/_static/css/supplementary.css" type="text/css" />
  <link rel="stylesheet" href="../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../_static/gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../_static/gallery-dataframe.css" type="text/css" />
  <link rel="stylesheet" href="../_static/gallery-rendered-html.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Contributing" href="contributing.html" />
    <link rel="prev" title="Core Concepts" href="core_concepts.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> GraKeL
          

          
            
            <img src="../_static/logo.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.1.8
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../documentation.html">Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="installation.html">Installing GraKeL</a></li>
<li class="toctree-l2"><a class="reference internal" href="introduction.html">A Short Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="core_concepts.html">Core Concepts</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Creating your Own Kernel</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#overriding-the-kernel-class-methods">Overriding the <code class="code docutils literal notranslate"><span class="pre">Kernel</span></code> class methods</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#which-methods-should-i-implement">Which methods should I implement</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-parse-input-pairwise-operation-methods">The <code class="code docutils literal notranslate"><span class="pre">parse_input</span></code>, <code class="code docutils literal notranslate"><span class="pre">pairwise_operation</span></code> methods</a></li>
<li class="toctree-l4"><a class="reference internal" href="#why-should-i-follow-the-list-format-on-parse-input">Why should I follow the list format on parse input?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#but-why-not-always-use-a-pairwise-operation">But why not always use a pairwise operation?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#what-if-i-don-t-want-to-follow-this-structure-at-all">What if I don’t want to follow, this structure at all?</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#getting-more-advanced">Getting more advanced</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#wrapping-c-functions-for-the-kernels-to-use">Wrapping C++ functions for the kernels to use</a></li>
<li class="toctree-l4"><a class="reference internal" href="#parallelization">Parallelization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bibliography">Bibliography</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contributing.html">Contributing</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks.html">Benchmarks</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../api.html">GraKeL</a></li>
<li class="toctree-l1"><a class="reference internal" href="../classes.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials.html">Tutorials</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">GraKeL</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../documentation.html">Documentation</a> &raquo;</li>
        
      <li>Creating your Own Kernel</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/documentation/creating_kernels.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="creating-your-own-kernel">
<span id="myok"></span><h1>Creating your Own Kernel<a class="headerlink" href="#creating-your-own-kernel" title="Permalink to this headline">¶</a></h1>
<p>As mentioned in the <a class="reference internal" href="core_concepts.html#core-concepts"><span class="std std-ref">Core Concepts</span></a> subsection, each kernel imported from the <code class="code docutils literal notranslate"><span class="pre">GraphKernel</span></code> generic wrapper
and found inside <code class="code docutils literal notranslate"><span class="pre">grakel.kernels</span></code> sub-package, inherits the <code class="code docutils literal notranslate"><span class="pre">Kernel</span></code> class found there.
In order to write any kernel that will be integrated (see <a class="reference internal" href="contributing.html#contributing"><span class="std std-ref">Contributing</span></a>), in our package we would like the
user to inherit that class. This may seem restricting but is not. We will try to demonstrate this in the
following sections and we would like to mention the fact that the whole kernel package <strong>is not final</strong>, but must
be always considered final when deploying a new package, because all the kernels should have a unified common interface.</p>
<div class="section" id="overriding-the-kernel-class-methods">
<h2>Overriding the <code class="code docutils literal notranslate"><span class="pre">Kernel</span></code> class methods<a class="headerlink" href="#overriding-the-kernel-class-methods" title="Permalink to this headline">¶</a></h2>
<p>In order to start we will present the current interface of the <code class="code docutils literal notranslate"><span class="pre">Kernel</span></code> class
(public methods) and guide the user how he can write a simple base <code class="code docutils literal notranslate"><span class="pre">Kernel</span></code>, such as the <em>vertex-histogram-kernel</em>.</p>
<p>The <em>vertex-histogram-kernel</em>, defined in <a class="bibtex reference internal" href="../kernels/random_walk.html#sugiyama2015halting" id="id1">[SB15]</a> p.4 section 2.3 is a simple kernel, that
calculates label histograms for each graph, that is: <em>counts the number of occurrences for each label
value and as a kernel between two graphs calculates the sum of products between frequencies of common
occurrences</em>.</p>
<p>To design this kernel let’s first learn some things about the kernel class.</p>
<div class="section" id="which-methods-should-i-implement">
<h3>Which methods should I implement<a class="headerlink" href="#which-methods-should-i-implement" title="Permalink to this headline">¶</a></h3>
<p>Each kernel should have the following methods:</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">__init__</span></code> method implemented. This method should be always overrided.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">fit</span></code>. Calculate features of the reference dataset.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">fit_transform</span></code>. Calculate features and the kernel matrix on the reference dataset.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">transform</span></code>. Calculate the kernel matrix between the fitted dataset and the transformed.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">diagonal</span></code>. Calculate the diagonal of the kernel matrix matrix produced between all elements of transform.</p></li>
</ul>
<p>So let’s start with our example and define an <code class="code docutils literal notranslate"><span class="pre">__init__</span></code> method for our <em>vertex-histogram-kernel</em>.</p>
<p>Let’s import some library elements we will use</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span><span class="p">,</span> <span class="n">Iterable</span>
<span class="kn">from</span> <span class="nn">grakel</span> <span class="kn">import</span> <span class="n">Kernel</span><span class="p">,</span> <span class="n">Graph</span>
</pre></div>
</div>
<p>and let’s define the <em>vertex-histogram-kernel</em></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">VertexHistogram</span><span class="p">(</span><span class="n">Kernel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Vertex Histogram kernel as found in :cite:`Sugiyama2015NIPS`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    None.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    None.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Define the graph format that this kernel needs (if needed)</span>
    <span class="c1"># _graph_format = &quot;auto&quot; (default: &quot;auto&quot;)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span>
                 <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="c1"># kernel_param_1=kernel_param_1_default,</span>
                 <span class="c1"># ...</span>
                 <span class="c1"># kernel_param_n=kernel_param_n_default,</span>
                 <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialise an `odd_sth` kernel.&quot;&quot;&quot;</span>

        <span class="c1"># Add new parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_parameters</span> <span class="o">|=</span> <span class="n">new_parameters</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">VertexHistogram</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">)</span>

        <span class="c1"># Get parameters and check the new ones</span>
        <span class="c1"># @for i=1 to num_new_parameters</span>
        <span class="c1">#   self.kernel_param_i = kernel_param_i</span>

        <span class="c1"># self.initialized_.update({</span>
        <span class="c1">#    param_needing_initialization_1 : False</span>
        <span class="c1">#             ...</span>
        <span class="c1">#    param_needing_initialization_m : False</span>
        <span class="c1"># })</span>

    <span class="k">def</span> <span class="nf">initialize_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize all transformer arguments, needing initialization.&quot;&quot;&quot;</span>
        <span class="c1"># If you want to implement a parallelization by your self here is your chance</span>
        <span class="c1"># If there is a pairwise operation on the Kernel object there is parallelization is implemented</span>
        <span class="c1"># Just run the initialise from father to initialise a joblib Parallel (if n_jobs is not None).</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">VertexHistogram</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">initialize_</span><span class="p">()</span>

        <span class="c1"># for i=1 .. m</span>
        <span class="c1">#     if not self.initialized_[&quot;param_needing_initialization_i&quot;]:</span>
        <span class="c1">#         # Apply checks (raise ValueError or TypeError accordingly)</span>
        <span class="c1">#         # calculate derived fields stored on self._derived_field_ia .. z</span>
        <span class="c1">#         self.initialized_[&quot;param_needing_initialization_i&quot;] = True</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>As you see there a few things we should note. Firstly the <code class="code docutils literal notranslate"><span class="pre">verbose</span></code>, <code class="code docutils literal notranslate"><span class="pre">normalize</span></code>,
<code class="code docutils literal notranslate"><span class="pre">n_jobs</span></code> parameters should be always included in the kernel definition and passed as is,
to the father method by calling his <code class="code docutils literal notranslate"><span class="pre">__init__</span></code> method. All <code class="code docutils literal notranslate"><span class="pre">__init__</span></code> parameters should be stored
to class method parameters with attributes of the exactly same name, as this is important for the sci-kit learn
transformer <strong>Pipeline</strong> and any needed initialization registered in <code class="code docutils literal notranslate"><span class="pre">initialized_</span></code> attribute must be registered
inside <code class="code docutils literal notranslate"><span class="pre">initialize_</span></code> method as an update of the father object. If the user decides to overwrite <code class="code docutils literal notranslate"><span class="pre">fit</span></code> or <code class="code docutils literal notranslate"><span class="pre">fit_transform</span></code> he
must call <code class="code docutils literal notranslate"><span class="pre">self.initialize_()</span></code> as the first command of any process inside the kernel. This allows a valid
parameter <em>resetting</em> through <code class="code docutils literal notranslate"><span class="pre">set_params</span></code>, satisfying an important aspect for <strong>Pipeline</strong> consistency.</p>
<p>Irrelevant from the interface the <code class="code docutils literal notranslate"><span class="pre">Kernel</span></code> class offers two methods, overriding which, a user can write
his own kernel. These methods are <code class="code docutils literal notranslate"><span class="pre">parse_input</span></code> and <code class="code docutils literal notranslate"><span class="pre">pairwise_operation</span></code>.</p>
</div>
<div class="section" id="the-parse-input-pairwise-operation-methods">
<h3>The <code class="code docutils literal notranslate"><span class="pre">parse_input</span></code>, <code class="code docutils literal notranslate"><span class="pre">pairwise_operation</span></code> methods<a class="headerlink" href="#the-parse-input-pairwise-operation-methods" title="Permalink to this headline">¶</a></h3>
<p>The <code class="code docutils literal notranslate"><span class="pre">parse_input</span></code> method actually produces all the features used from the kernel.
The default procedure is that both <code class="code docutils literal notranslate"><span class="pre">fit</span></code> and <code class="code docutils literal notranslate"><span class="pre">transform</span></code> use <code class="code docutils literal notranslate"><span class="pre">parse_input</span></code>
to create features for each graph producing a list where each element corresponds to the index
indicating that graph, from the corresponding iterable (while ignoring empty elements).
Those lists are then used feeding single list elements to the <code class="code docutils literal notranslate"><span class="pre">pairwise_operation</span></code>
method, calculating a final kernel value.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In order not to repeat again-again the word <em>kernel</em>, when defining a kernel class
this word is omitted on the kernel name definition.</p>
</div>
<p>So to continue or example we first define <code class="code docutils literal notranslate"><span class="pre">parse_input</span></code> inside the <code class="code docutils literal notranslate"><span class="pre">VertexHistogram</span></code> class:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">parse_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parse and check the given input for vertex kernel.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : iterable</span>
<span class="sd">            For the input to pass the test, we must have:</span>
<span class="sd">            Each element must be an iterable with at most three features and at</span>
<span class="sd">            least one. The first that is obligatory is a valid graph structure</span>
<span class="sd">            (adjacency matrix or edge_dictionary) while the second is</span>
<span class="sd">            node_labels and the third edge_labels (that fitting the given graph</span>
<span class="sd">            format).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : list</span>
<span class="sd">            List of frequency-histogram for each Graph.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;input must be an iterable</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">X</span><span class="p">)):</span>
                <span class="n">is_iter</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">is_iter</span><span class="p">:</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">is_iter</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Ignoring empty element on index: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
                        <span class="k">continue</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Our element is an iterable of at least 2 elements</span>
                        <span class="n">labels</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Graph</span><span class="p">:</span>
                    <span class="c1"># get labels in any existing format</span>
                    <span class="n">labels</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">get_labels</span><span class="p">(</span><span class="n">purpose</span><span class="o">=</span><span class="s2">&quot;any&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;each element of X must be either a &#39;</span> <span class="o">+</span>
                                     <span class="s1">&#39;graph object or a list with at least &#39;</span> <span class="o">+</span>
                                     <span class="s1">&#39;a graph like object and node labels &#39;</span> <span class="o">+</span>
                                     <span class="s1">&#39;dict </span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

                <span class="c1"># Append frequencies for the current Graph</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Counter</span><span class="p">(</span><span class="n">labels</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;parsed input is empty&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">out</span>
</pre></div>
</div>
<p>The procedure of reading the input is really standard, but must be specified for each kernel
according to its minimum acceptable input, that is the least elements with which it can be computed.
After reading the labels, we calculate frequencies with a <code class="code docutils literal notranslate"><span class="pre">Counter</span></code> on the label values, while
adding them to a list for all the non empty element of the iterable. Finally on those list
elements that are produced from <code class="code docutils literal notranslate"><span class="pre">parse_input</span></code> the pairwise operation that calculates
the kernel value is</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">pairwise_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate sum of frequency products.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x, y : Counter</span>
<span class="sd">            Label-Frequency Counters as occur from `parse_input`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        kernel : number</span>
<span class="sd">            The kernel value.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
</pre></div>
</div>
<p>where we count the <span class="math notranslate nohighlight">\(\sum_{l \in L_{i} \cap L_{j}} f^{i}_{l}*f^{j}_{l}\)</span>, using the property of a <code class="code docutils literal notranslate"><span class="pre">Counter</span></code>
object, returning a <strong>0</strong> value on empty occurrences.</p>
<p>Now going back to the fascinating water-example</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H2O</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s1">&#39;O&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H3O</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s1">&#39;O&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="s1">&#39;H&#39;</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vh_kernel</span> <span class="o">=</span> <span class="n">vertex_histogram</span><span class="p">(</span><span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vh_kernel</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">([</span><span class="n">H2O</span><span class="p">])[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vh_kernel</span><span class="o">.</span><span class="n">transform</span><span class="p">([</span><span class="n">H3O</span><span class="p">])[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">0.9899494936611665</span>
</pre></div>
</div>
<p>So this kernel works!</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="code docutils literal notranslate"><span class="pre">normalize</span></code> argument uses <code class="code docutils literal notranslate"><span class="pre">diagonal</span></code>, which makes it a good way of checking if this method is implemented also (correctly).</p>
</div>
</div>
<div class="section" id="why-should-i-follow-the-list-format-on-parse-input">
<h3>Why should I follow the list format on parse input?<a class="headerlink" href="#why-should-i-follow-the-list-format-on-parse-input" title="Permalink to this headline">¶</a></h3>
<p>You can still avoid changing the list format result on <code class="code docutils literal notranslate"><span class="pre">parse_input</span></code>, by instead of overriding pairwise operation, doing so with overriding <code class="code docutils literal notranslate"><span class="pre">_calculate_kernel_matrix</span></code>
method. This method must be able to receive one element whose default value is <code class="code docutils literal notranslate"><span class="pre">None</span></code>, where if it is, the method should calculate the kernel matrix between elements of <code class="code docutils literal notranslate"><span class="pre">self.X</span></code> (where the output of <code class="code docutils literal notranslate"><span class="pre">parse_input</span></code> is stored) and otherwise calculate between the input of <code class="code docutils literal notranslate"><span class="pre">Y</span></code> (which also comes from <code class="code docutils literal notranslate"><span class="pre">parse_input</span></code>) and <code class="code docutils literal notranslate"><span class="pre">self.X</span></code>.
By doing so, the developer needs to override the <code class="code docutils literal notranslate"><span class="pre">diagonal</span></code> method, because it normally uses <code class="code docutils literal notranslate"><span class="pre">pairwise_operation</span></code>. The diagonal method can also see <strong>the last transformed
input as resulted from :code:`parse_input`</strong> inside the attribute <code class="code docutils literal notranslate"><span class="pre">self._Y</span></code>.</p>
</div>
<div class="section" id="but-why-not-always-use-a-pairwise-operation">
<h3>But why not always use a pairwise operation?<a class="headerlink" href="#but-why-not-always-use-a-pairwise-operation" title="Permalink to this headline">¶</a></h3>
<p>There are cases where the matrix calculation as a batch is much more computationally efficient.
This can be demonstrated, by utilizing libraries such as <code class="code docutils literal notranslate"><span class="pre">numpy</span></code>.</p>
<p>Let’s go back to the vertex histogram kernel and do so. The class definition of <code class="code docutils literal notranslate"><span class="pre">__init__</span></code> stands as above.
We will redefine the <code class="code docutils literal notranslate"><span class="pre">parse_input</span></code> method, in order for utilizing the <code class="code docutils literal notranslate"><span class="pre">numpy</span></code> package.</p>
<p>Let’s start with some new import statements</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span><span class="p">,</span> <span class="n">Iterable</span>
<span class="kn">from</span> <span class="nn">sklearn.utils.validation</span> <span class="kn">import</span> <span class="n">check_is_fitted</span>
<span class="kn">from</span> <span class="nn">grakel</span> <span class="kn">import</span> <span class="n">Kernel</span><span class="p">,</span> <span class="n">Graph</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">einsum</span>
</pre></div>
</div>
<p>and define the new <code class="code docutils literal notranslate"><span class="pre">parse_input</span></code></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">VertexHistogram</span><span class="p">(</span><span class="n">Kernel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Vertex Histogram kernel as found in :cite:`Sugiyama2015NIPS`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    None.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    None.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Define the graph format that this kernel needs (if needed)</span>
    <span class="c1"># _graph_format = &quot;auto&quot; (default: &quot;auto&quot;)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span>
                 <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="c1"># kernel_param_1=kernel_param_1_default,</span>
                 <span class="c1"># ...</span>
                 <span class="c1"># kernel_param_n=kernel_param_n_default,</span>
                 <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialise an `odd_sth` kernel.&quot;&quot;&quot;</span>

        <span class="c1"># Add new parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valid_parameters</span> <span class="o">|=</span> <span class="n">new_parameters</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">VertexHistogram</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">)</span>

        <span class="c1"># Get parameters and check the new ones</span>
        <span class="c1"># @for i=1 to num_new_parameters</span>
        <span class="c1">#   self.kernel_param_i = kernel_param_i</span>

        <span class="c1"># self.initialized_.update({</span>
        <span class="c1">#    param_needing_initialization_1 : False</span>
        <span class="c1">#             ...</span>
        <span class="c1">#    param_needing_initialization_m : False</span>
        <span class="c1"># })</span>

    <span class="k">def</span> <span class="nf">initialize_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize all transformer arguments, needing initialization.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialized_</span><span class="p">[</span><span class="s2">&quot;n_jobs&quot;</span><span class="p">]:</span>
            <span class="c1"># n_jobs is not used in this kernel</span>
            <span class="c1"># numpy utilises low-level parallelization for calculating matrix operations</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;no implemented parallelization for VertexHistogram&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">initialized_</span><span class="p">[</span><span class="s2">&quot;n_jobs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># for i=1 .. m</span>
        <span class="c1">#     if not self.initialized_[&quot;param_needing_initialization_i&quot;]:</span>
        <span class="c1">#         # Apply checks (raise ValueError or TypeError accordingly)</span>
        <span class="c1">#         # calculate derived fields stored on self._derived_field_ia .. z</span>
        <span class="c1">#         self.initialized_[&quot;param_needing_initialization_i&quot;] = True</span>


    <span class="k">def</span> <span class="nf">parse_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parse and check the given input for vertex kernel.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : iterable</span>
<span class="sd">            For the input to pass the test, we must have:</span>
<span class="sd">            Each element must be an iterable with at most three features and at</span>
<span class="sd">            least one. The first that is obligatory is a valid graph structure</span>
<span class="sd">            (adjacency matrix or edge_dictionary) while the second is</span>
<span class="sd">            node_labels and the third edge_labels (that fitting the given graph</span>
<span class="sd">            format).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : np.array, shape=(len(X), n_labels)</span>
<span class="sd">            A numpy array for frequency (cols) histograms for all Graphs (rows).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;input must be an iterable</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(),</span> <span class="nb">list</span><span class="p">(),</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_method_calling</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span> <span class="o">=</span> <span class="n">labels</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_method_calling</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">)</span>
            <span class="n">ni</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">X</span><span class="p">)):</span>
                <span class="n">is_iter</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">is_iter</span><span class="p">:</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">is_iter</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Ignoring empty element&#39;</span> <span class="o">+</span>
                                      <span class="s1">&#39; on index: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
                        <span class="k">continue</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Our element is an iterable of at least 2 elements</span>
                        <span class="n">L</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Graph</span><span class="p">:</span>
                    <span class="c1"># get labels in any existing format</span>
                    <span class="n">L</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">get_labels</span><span class="p">(</span><span class="n">purpose</span><span class="o">=</span><span class="s2">&quot;any&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;each element of X must be either a &#39;</span> <span class="o">+</span>
                                     <span class="s1">&#39;graph object or a list with at least &#39;</span> <span class="o">+</span>
                                     <span class="s1">&#39;a graph like object and node labels &#39;</span> <span class="o">+</span>
                                     <span class="s1">&#39;dict </span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

                <span class="c1"># construct the data input for the numpy array</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">frequency</span><span class="p">)</span> <span class="ow">in</span> <span class="n">Counter</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">values</span><span class="p">())</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="c1"># for the row that corresponds to that graph</span>
                    <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ni</span><span class="p">)</span>

                    <span class="c1"># and to the value that this label is indexed</span>
                    <span class="n">col_idx</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">col_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="c1"># if not indexed, add the new index (the next)</span>
                        <span class="n">col_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
                        <span class="n">labels</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">col_idx</span>

                    <span class="c1"># designate the certain column information</span>
                    <span class="n">cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col_idx</span><span class="p">)</span>

                    <span class="c1"># as well as the frequency value to data</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frequency</span><span class="p">)</span>
                <span class="n">ni</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># Initialise the feature matrix</span>
            <span class="n">features</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">ni</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)))</span>
            <span class="n">features</span><span class="p">[</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>

            <span class="k">if</span> <span class="n">ni</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;parsed input is empty&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">features</span>
</pre></div>
</div>
<p>Let’s stop here at two points.</p>
<ul class="simple">
<li><p>What is <code class="code docutils literal notranslate"><span class="pre">self._method_calling</span></code>? The parse input is a global method used by three basic functions (<code class="code docutils literal notranslate"><span class="pre">fit</span></code>, <code class="code docutils literal notranslate"><span class="pre">fit_transform</span></code> and <code class="code docutils literal notranslate"><span class="pre">transform</span></code>)
to extract certain features, from the input while parsing it. Although in most cases the procedure is unique there are minor points where the execution
of the algorithm should differentiate, according to if the information is intended for the fit method or not. <code class="code docutils literal notranslate"><span class="pre">self._method_calling</span></code> is a class attribute
that should be initialized in <em>1</em> if any <em>method</em> is called from <code class="code docutils literal notranslate"><span class="pre">fit</span></code>, to <em>2</em> if it is called from <code class="code docutils literal notranslate"><span class="pre">fit_transform</span></code> and to <em>3</em> if it is called from
<code class="code docutils literal notranslate"><span class="pre">transform</span></code>. The ordinary <code class="code docutils literal notranslate"><span class="pre">fit_transform</span></code>, calls <code class="code docutils literal notranslate"><span class="pre">fit</span></code> to parse the input in which case <code class="code docutils literal notranslate"><span class="pre">self._method_calling</span></code> will never be set to <em>2</em>, but it is added in favor of <em>completeness</em>.</p></li>
<li><p>Why are you doing something else on <code class="code docutils literal notranslate"><span class="pre">fit</span></code> and on <code class="code docutils literal notranslate"><span class="pre">transform</span></code>? Generally <code class="code docutils literal notranslate"><span class="pre">fit</span></code> stands for setting the reference dataset, that is, it holds information that
act as reference for any further transformation. In our case the <code class="code docutils literal notranslate"><span class="pre">labels</span></code>, appearing in all graphs are enumerated in order to be added on a feature matrix.
The labels corresponding to the dataset of <code class="code docutils literal notranslate"><span class="pre">fit</span></code> should occupy the first position of the feature matrix, where any new labels of the matrix should be
added on new positions coherently and forgotten (because there is no need to be remembered).</p></li>
</ul>
<p>Now we would like to define the <code class="code docutils literal notranslate"><span class="pre">_calculate_kernel_matrix</span></code> method, calculating simple the kernel matrix as a result of a simple dot product</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">_calculate_kernel_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the kernel matrix given a target_graph and a kernel.</span>

<span class="sd">        Each a matrix is calculated between all elements of Y on the rows and</span>
<span class="sd">        all elements of X on the columns.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Y : np.array, default=None</span>
<span class="sd">            The array between samples and features.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        K : numpy array, shape = [n_targets, n_inputs]</span>
<span class="sd">            The kernel matrix: a calculation between all pairs of graphs</span>
<span class="sd">            between targets and inputs. If Y is None targets and inputs</span>
<span class="sd">            are the taken from self.X. Otherwise Y corresponds to targets</span>
<span class="sd">            and self.X to inputs.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">Y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">K</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">K</span> <span class="o">=</span> <span class="n">Y</span><span class="p">[:,</span> <span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">K</span>
</pre></div>
</div>
<p>as well as the diagonal method (using Einstein summation convention which is a really fast method for speeding up
the diagonal calculation of the final matrix, as found <a class="reference external" href="https://stackoverflow.com/questions/14758283/is-there-a-numpy-scipy-dot-product-calculating-only-the-diagonal-entries-of-the">here</a>)</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">diagonal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the kernel matrix diagonal of the fitted data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        X_diag : np.array</span>
<span class="sd">            The diagonal of the kernel matrix, of the fitted. This consists</span>
<span class="sd">            of each element calculated with itself.</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check is fit had been called</span>
        <span class="n">check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;_Y&#39;</span><span class="p">])</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">check_is_fitted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;_X_diag&#39;</span><span class="p">])</span>
        <span class="k">except</span> <span class="n">NotFittedError</span><span class="p">:</span>
            <span class="c1"># Calculate diagonal of X</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_X_diag</span> <span class="o">=</span> <span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,ij-&gt;i&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>


        <span class="n">Y_diag</span> <span class="o">=</span> <span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,ij-&gt;i&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Y</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_X_diag</span><span class="p">,</span> <span class="n">Y_diag</span>
</pre></div>
</div>
<p>Now let’s solve a classification problem on the <strong>“DD”</strong> dataset, by following a standard procedure.
First import and download the dataset</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">grakel</span> <span class="kn">import</span> <span class="n">GraphKernel</span><span class="p">,</span> <span class="n">datasets</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">DD</span> <span class="o">=</span> <span class="n">datasets</span><span class="o">.</span><span class="n">fetch_dataset</span><span class="p">(</span><span class="s2">&quot;DD&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">DD_data</span> <span class="o">=</span> <span class="n">DD</span><span class="o">.</span><span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">DD_classes</span> <span class="o">=</span> <span class="n">DD</span><span class="o">.</span><span class="n">target</span>
</pre></div>
</div>
<p>afterwards split train/test in a pseudo-random way holding</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">DD_data</span><span class="p">,</span> <span class="n">DD_classes</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For understanding why 42, was chosen as a <code class="code docutils literal notranslate"><span class="pre">random_state</span></code>, check <a class="reference external" href="https://www.google.fr/search?q=the%20answer%20to%20life%20the%20universe%20and%20everything">this</a>.</p>
</div>
<p>now let’s calculate the <code class="code docutils literal notranslate"><span class="pre">K_train</span></code> and <code class="code docutils literal notranslate"><span class="pre">K_test</span></code> kernels as</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vh_kernel</span> <span class="o">=</span> <span class="n">vertex_histogram</span><span class="p">(</span><span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K_train</span> <span class="o">=</span> <span class="n">vh_kernel</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K_test</span> <span class="o">=</span> <span class="n">vh_kernel</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
</pre></div>
</div>
<p>and finally classify, by using/finding the best C (that is a parameter emphasizing to the SVM,
<a class="reference external" href="https://stats.stackexchange.com/questions/31066/what-is-the-influence-of-c-in-svms-with-linear-kernel">how much you want to avoid misclassifying each training example</a>)</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">accuracy_score</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">SVC</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">arange</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">C_grid</span> <span class="o">=</span> <span class="mf">10.</span> <span class="o">**</span> <span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">DD</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">acc_score</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">C_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">clf</span> <span class="o">=</span> <span class="n">SVC</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="s1">&#39;precomputed&#39;</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">C_grid</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">K_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">y_pred</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">K_test</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">acc_score</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">acc_score</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">accuracy_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<p>which produces an accuracy score close to the maximum 78.2% documented on <a class="bibtex reference internal" href="../kernels/weisfeiler_lehman_optimal_assignment.html#kriege2016valid" id="id2">[KGW16]</a></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">acc_score</span><span class="p">,</span> <span class="s2">&quot;%&quot;</span><span class="p">)</span>
<span class="go">76,27 %</span>
</pre></div>
</div>
</div>
<div class="section" id="what-if-i-don-t-want-to-follow-this-structure-at-all">
<h3>What if I don’t want to follow, this structure at all?<a class="headerlink" href="#what-if-i-don-t-want-to-follow-this-structure-at-all" title="Permalink to this headline">¶</a></h3>
<p>Although the basic methods (<code class="code docutils literal notranslate"><span class="pre">fit</span></code>, <code class="code docutils literal notranslate"><span class="pre">fit_transform</span></code>, <code class="code docutils literal notranslate"><span class="pre">transform</span></code>, <code class="code docutils literal notranslate"><span class="pre">diagonal</span></code>) are needed for the kernel
pipeline, the kernel structure is not imposed, but proposed. The user can always write her/his methods, as long as they are coherent with some design specifications needed for a <em>valid</em> kernel, mainly:</p>
<ul class="simple">
<li><p>Unified input support between all structures, while expecting input in a relevant way, that is accepting a <code class="code docutils literal notranslate"><span class="pre">Graph</span></code> type-object
or an iterable of at least one element, which position <strong>0</strong> should signify the graph Object, position <strong>1</strong> should signify the
node labels and position <strong>2</strong> the edge labels.</p></li>
<li><p>Support of <code class="code docutils literal notranslate"><span class="pre">normalization</span></code> in a valid way is imperative.</p></li>
<li><p>The method <code class="code docutils literal notranslate"><span class="pre">diagonal</span></code> is used in order for nested-graph-kernels (such as <em>Weisfeiler-Lehman</em>) to be able to calculate a correct
<em>normalized</em> output, so it is also imperative, to be valid. Its output should be supported both as a scalar and as a vector.</p></li>
</ul>
</div>
</div>
<div class="section" id="getting-more-advanced">
<h2>Getting more advanced<a class="headerlink" href="#getting-more-advanced" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This documentation entry is a preamble to the <a class="reference internal" href="contributing.html#contributing"><span class="std std-ref">Contributing</span></a> section and will evolve much more as users contribute to this project.</p>
</div>
<p>What if you do not want just to write your kernel, but fork the project in order to integrate an optimized version of your new kernel.</p>
<div class="section" id="wrapping-c-functions-for-the-kernels-to-use">
<h3>Wrapping C++ functions for the kernels to use<a class="headerlink" href="#wrapping-c-functions-for-the-kernels-to-use" title="Permalink to this headline">¶</a></h3>
<p>We have implemented a simple <a class="reference external" href="http://cython.org/">Cython</a> extension for the use of <strong>C++</strong> inside python kernel implementation.
This package can be found inside <code class="code docutils literal notranslate"><span class="pre">grakel/kernels/_c_functions</span></code>. There the user can find the following files.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>grakel/kernels/_c_functions
                    ├── functions.cpp
                    ├── functions.pxd
                    ├── functions.pyx
                    ├── include
                    │      └── functions.hpp
                    └── src
                         └── *.cpp
</pre></div>
</div>
<p>In order to add a new function, what he/she should do is to add its source file inside <code class="code docutils literal notranslate"><span class="pre">src</span></code> while including/implementing
its definition found inside the <code class="code docutils literal notranslate"><span class="pre">include/functions.hpp</span></code>. Afterwards by externing the function definition inside the library
file <code class="code docutils literal notranslate"><span class="pre">functions.pxd</span></code>, by importing it from <code class="code docutils literal notranslate"><span class="pre">include/functions.hpp</span></code> you should add it inside the functions.pyx, file
where the essential IO wraping of the C++ function is done inside Python. Finally you must add the address of new <em>C++</em> you wrote on
the <code class="code docutils literal notranslate"><span class="pre">_c_functions</span></code> <code class="code docutils literal notranslate"><span class="pre">Extension</span></code> found on <code class="code docutils literal notranslate"><span class="pre">setup.py</span></code>, by adding it to the list given to the <code class="code docutils literal notranslate"><span class="pre">sources</span></code> argument.</p>
</div>
<div class="section" id="parallelization">
<h3>Parallelization<a class="headerlink" href="#parallelization" title="Permalink to this headline">¶</a></h3>
<p>A basic infrastracture for utilizing parallelization possibilities of the kernel computation, was created inside the kernel class.
The user define n_jobs for each kernel and the indexes of the kernel matrix are <em>linearized</em> and splitted to the effective number of jobs
on which the pairwise operation is applied in parallel. We use the <code class="code docutils literal notranslate"><span class="pre">joblib</span></code> library, as found inside the <code class="code docutils literal notranslate"><span class="pre">sklearn.externals</span></code>.
On certain frameworks (Weisfeiler Lehman, Hadamard Code) the strategy for applying parallel kernel calculation is different, where the
task is the single kernel calculation of a kernel matrix from the base kernel. Parallelization is a feature we wanted to include in our
library because it can give the opportunity to the user to increase the efficiency of kernel matrix computation on large dataset, <strong>although
the induced overhead in the most cases seems not to worth it</strong>. The developer can either follow our road and call the initialization
of the father method creating a <code class="code docutils literal notranslate"><span class="pre">joblib.Parallel</span></code> object with a <code class="code docutils literal notranslate"><span class="pre">threading</span></code> <em>backend api</em> (stored in <code class="code docutils literal notranslate"><span class="pre">_parallel</span></code>) and use it inside
her/his code anyway he wants or follow a different strategy that seems to have a computational advantage. In case someone wants to contribute
in redisigning and extending the parallelization proccess he/she can see how in <a class="reference internal" href="contributing.html#contributing"><span class="std std-ref">Contributing</span></a>.</p>
</div>
<div class="section" id="bibliography">
<h3>Bibliography<a class="headerlink" href="#bibliography" title="Permalink to this headline">¶</a></h3>
<p id="bibtex-bibliography-documentation/creating_kernels-0"><dl class="citation">
<dt class="bibtex label" id="kriege2016valid"><span class="brackets"><a class="fn-backref" href="#id2">KGW16</a></span></dt>
<dd><p>Nils M Kriege, Pierre-Louis Giscard, and Richard Wilson. On Valid Optimal Assignment Kernels and Applications to Graph Classification. In <em>Advances in Neural Information Processing Systems</em>, 1623–1631. 2016.</p>
</dd>
<dt class="bibtex label" id="sugiyama2015halting"><span class="brackets"><a class="fn-backref" href="#id1">SB15</a></span></dt>
<dd><p>Mahito Sugiyama and Karsten M. Borgwardt. Halting in Random Walk Kernels. In <em>Advances in Neural Information Processing Systems</em>, 1639–1647. 2015.</p>
</dd>
</dl>
</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="contributing.html" class="btn btn-neutral float-right" title="Contributing" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="core_concepts.html" class="btn btn-neutral float-left" title="Core Concepts" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2019, DaSciM (BSD License).

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>