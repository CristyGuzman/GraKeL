

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>A Short Introduction &mdash; GraKeL 0.1.8 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/_static/css/supplementary.css" type="text/css" />
  <link rel="stylesheet" href="../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../_static/gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../_static/gallery-dataframe.css" type="text/css" />
  <link rel="stylesheet" href="../_static/gallery-rendered-html.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Core Concepts" href="core_concepts.html" />
    <link rel="prev" title="Installing GraKeL" href="installation.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> GraKeL
          

          
            
            <img src="../_static/logo.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.1.8
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../documentation.html">Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="installation.html">Installing GraKeL</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">A Short Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#what-is-grakel">What is GraKeL?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#what-is-a-graph-kernel">What is a Graph Kernel?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#creating-a-graph">Creating a Graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="#assigning-labels-attributes-to-nodes">Assigning Labels/Attributes to Nodes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#assigning-labels-attributes-to-edges">Assigning Labels/Attributes to Edges</a></li>
<li class="toctree-l3"><a class="reference internal" href="#initializing-a-graph-kernel">Initializing a Graph Kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="#initializing-a-framework">Initializing a Framework</a></li>
<li class="toctree-l3"><a class="reference internal" href="#computing-the-kernel-between-two-graphs">Computing the Kernel Between Two Graphs</a></li>
<li class="toctree-l3"><a class="reference internal" href="#performing-graph-classification">Performing Graph Classification</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bibliography">Bibliography</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="core_concepts.html">Core Concepts</a></li>
<li class="toctree-l2"><a class="reference internal" href="creating_kernels.html">Creating your Own Kernel</a></li>
<li class="toctree-l2"><a class="reference internal" href="contributing.html">Contributing</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks.html">Benchmarks</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../api.html">GraKeL</a></li>
<li class="toctree-l1"><a class="reference internal" href="../classes.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials.html">Tutorials</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">GraKeL</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../documentation.html">Documentation</a> &raquo;</li>
        
      <li>A Short Introduction</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/documentation/introduction.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <span class="target" id="introduction"></span><div class="section" id="a-short-introduction">
<h1>A Short Introduction<a class="headerlink" href="#a-short-introduction" title="Permalink to this headline">¶</a></h1>
<div class="section" id="what-is-grakel">
<h2>What is GraKeL?<a class="headerlink" href="#what-is-grakel" title="Permalink to this headline">¶</a></h2>
<p>The problem of accurately measuring the similarity between graphs is at the core of many applications in a variety of disciplines. Graph kernels have recently emerged as a promising approach to this problem. GraKeL is a library that provides implementations of several well-established graph kernels, unifying them into a common framework. The library is written in Python following scikit-learn’s philosophy. GraKeL makes it easy to build a complete machine learning pipeline for tasks such as graph classification and clustering.</p>
</div>
<div class="section" id="what-is-a-graph-kernel">
<h2>What is a Graph Kernel?<a class="headerlink" href="#what-is-a-graph-kernel" title="Permalink to this headline">¶</a></h2>
<p>A graph kernel is a symmetric, positive semidefinite function on the set of graphs <span class="math notranslate nohighlight">\(\mathcal{G}\)</span>. Once we define such a function <span class="math notranslate nohighlight">\(k : \mathcal{G} \times \mathcal{G} \rightarrow \mathbb{R}\)</span> on the set <span class="math notranslate nohighlight">\(\mathcal{G}\)</span>, it is known that there exists a map <span class="math notranslate nohighlight">\(\phi : \mathcal{G} \rightarrow \mathcal{H}\)</span> into a <a class="reference external" href="https://en.wikipedia.org/wiki/Hilbert_space">Hilbert space</a> <span class="math notranslate nohighlight">\(\mathcal{H}\)</span>, such that:</p>
<div class="math notranslate nohighlight">
\[k(G_i, G_j) = \langle \phi(G_i), \phi(G_j) \rangle_{\mathcal{H}}\]</div>
<p>for all <span class="math notranslate nohighlight">\(G_i, G_j \in \mathcal{G}\)</span> where <span class="math notranslate nohighlight">\(\langle\cdot, \cdot\rangle_{\mathcal{H}}\)</span> is the inner product in <span class="math notranslate nohighlight">\(\mathcal{H}\)</span>. Roughly speaking, a graph kernel is a function that measures the similarity of two graphs.</p>
</div>
<div class="section" id="creating-a-graph">
<h2>Creating a Graph<a class="headerlink" href="#creating-a-graph" title="Permalink to this headline">¶</a></h2>
<p>A graph is used to model a set of objects (i.e., nodes) and the relationships between them (i.e., edges). A single graph in GraKeL is described by an instance of <a class="reference internal" href="../generated/grakel.Graph.html#grakel.Graph" title="grakel.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">grakel.Graph</span></code></a>. Traditionally, the two main structures used to represent a graph are the <em>adjacency matrix</em> and the <em>list of edges</em>. Both these representations can give rise to valid graph objects. The following Figure illustrates an unweighted, undirected graph with three nodes and two edges, and we show how we can generate graph objects that correspond to this example graph using the two representations mentioned above. Note that the graph has only two edges, however, we need to define four edges to account for both directions of each edge.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/example_graph.svg"><img alt="../_images/example_graph.svg" height="952" src="../_images/example_graph.svg" width="1432" /></a>
</div>
<ul>
<li><p>Edgelist representation:</p>
<ul>
<li><div class="line-block">
<div class="line">A dictionary keyed by node to the list of its neighbors.</div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">edges</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">]}</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><div class="line-block">
<div class="line">Iterable of tuples of lenght 2. Each tuple corresponds to an edge.</div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">edges</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
</li>
<li><p>Adjacency matrix representation:</p>
<ul>
<li><div class="line-block">
<div class="line">Array-like lists of lists.</div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">adj</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">adj</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><div class="line-block">
<div class="line">NumPy array.</div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">adj</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">adj</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><div class="line-block">
<div class="line">Scipy sparse matrix.</div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">adj</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">adj</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
</li>
</ul>
<p>A graph is <em>directed</em> if its edges have a direction associated with them. The Figure below shows an directed, unweighted graph with three nodes and three directed edges.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/example_graph_directed.svg"><img alt="../_images/example_graph_directed.svg" height="952" src="../_images/example_graph_directed.svg" width="1432" /></a>
</div>
<ul>
<li><p>Edgelist representation:</p>
<ul>
<li><div class="line-block">
<div class="line">A dictionary keyed by node to the list of its neighbors.</div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">edges</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">]}</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><div class="line-block">
<div class="line">Iterable of tuples of lenght 2. Each tuple corresponds to an edge.</div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">edges</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
</li>
<li><p>Adjacency matrix representation:</p>
<ul>
<li><div class="line-block">
<div class="line">Array-like lists of lists.</div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">adj</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">adj</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><div class="line-block">
<div class="line">NumPy array.</div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">adj</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">adj</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><div class="line-block">
<div class="line">Scipy sparse matrix.</div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">adj</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">adj</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
</li>
</ul>
<p>A graph is <em>weighted</em> if its edges have weights. The Figure below shows a weighted, undirected graph with three nodes and two edges.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/example_graph_weighted.svg"><img alt="../_images/example_graph_weighted.svg" height="952" src="../_images/example_graph_weighted.svg" width="1432" /></a>
</div>
<ul>
<li><p>Edgelist representation:</p>
<ul>
<li><div class="line-block">
<div class="line">A dictionary keyed by nodes to a dictionary keyed by neighbors to edge weights.</div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">edges</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mf">0.2</span><span class="p">},</span> <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">},</span> <span class="mi">3</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mf">0.2</span><span class="p">}}</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><div class="line-block">
<div class="line">A dictionary keyed by edges to their weights.</div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">edges</span> <span class="o">=</span> <span class="p">{(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span> <span class="mf">0.5</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span> <span class="mf">0.2</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span> <span class="mf">0.5</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span> <span class="mf">0.2</span><span class="p">}</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><div class="line-block">
<div class="line">Iterable of tuples of length 3. Each tuple corresponds to an edge and its weight.</div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">edges</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)]</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
</li>
<li><p>Adjacency matrix representation:</p>
<ul>
<li><div class="line-block">
<div class="line">Array-like lists of lists.</div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">adj</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">adj</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><div class="line-block">
<div class="line">NumPy array.</div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">adj</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">adj</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><div class="line-block">
<div class="line">Scipy sparse matrix.</div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">adj</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">adj</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="assigning-labels-attributes-to-nodes">
<h2>Assigning Labels/Attributes to Nodes<a class="headerlink" href="#assigning-labels-attributes-to-nodes" title="Permalink to this headline">¶</a></h2>
<p>A graph may contain node labels or node attributes. There is an <em>optional</em> attribute of <a class="reference internal" href="../generated/grakel.Graph.html#grakel.Graph" title="grakel.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">grakel.Graph</span></code></a> which allows us to assign labels or attributes to the nodes.</p>
<p>A node-labeled graph is a graph endowed with a function <span class="math notranslate nohighlight">\(\ell : V \rightarrow \mathcal{L}\)</span> that assigns labels to the vertices of the graph from a label set <span class="math notranslate nohighlight">\(\mathcal{L}\)</span>. Note that <span class="math notranslate nohighlight">\(V\)</span> is the set of nodes of the graph. The Figure below shows a node-labeled graph with three nodes and two edges. The nodes are labeled with symbols from <span class="math notranslate nohighlight">\(\mathcal{L} = \{ a, b \}\)</span>.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/example_graph_labeled.svg"><img alt="../_images/example_graph_labeled.svg" height="1756" src="../_images/example_graph_labeled.svg" width="2073" /></a>
</div>
<ul>
<li><div class="line-block">
<div class="line">A dictionary keyed by nodes to their labels.</div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">edges</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">]}</span>
<span class="n">node_labels</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="s1">&#39;a&#39;</span><span class="p">}</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">node_labels</span><span class="o">=</span><span class="n">node_labels</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><div class="line-block">
<div class="line">A dictionary keyed by node indices (i.e., <span class="math notranslate nohighlight">\(0,\ldots,(|V|-1)\)</span>) to their labels.</div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">adj</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="n">node_labels</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;a&#39;</span><span class="p">}</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">node_labels</span><span class="o">=</span><span class="n">node_labels</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
<p>A node-attributed graph is a graph endowed with a function <span class="math notranslate nohighlight">\(f : V \rightarrow \mathbb{R}^d\)</span> that assigns real-valued vectors to the vertices of the graph. The following Figure illustrates a node-attributed graph with three nodes and two edges.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/example_graph_attributed.svg"><img alt="../_images/example_graph_attributed.svg" height="2027" src="../_images/example_graph_attributed.svg" width="3371" /></a>
</div>
<ul>
<li><div class="line-block">
<div class="line">A dictionary keyed by nodes to their attributes.</div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>edges = {1: [2, 3], 2: [1], 3: [1]}
node_attributes = {1: [1.2, 0.5], 2: [2.8, −0.6], 3: [0.7, 1.1]}
G = Graph(edges, node_labels=node_attributes)
</pre></div>
</div>
</li>
<li><div class="line-block">
<div class="line">A dictionary keyed by node indices (i.e., <span class="math notranslate nohighlight">\(0,\ldots,(|V|-1)\)</span>) to their attributes.</div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>adj = [[0, 1, 1], [1, 0, 0], [1, 0, 0]]
node_attributes = {0: [1.2, 0.5], 1: [2.8, −0.6], 2: [0.7, 1.1]}
G = Graph(adj, node_labels=node_attributes)
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="assigning-labels-attributes-to-edges">
<h2>Assigning Labels/Attributes to Edges<a class="headerlink" href="#assigning-labels-attributes-to-edges" title="Permalink to this headline">¶</a></h2>
<p>A graph may contain edge labels or edge attributes. There is an <em>optional</em> attribute of <a class="reference internal" href="../generated/grakel.Graph.html#grakel.Graph" title="grakel.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">grakel.Graph</span></code></a> which allows us to assign labels or attributes to the edges.</p>
<p>An edge-labeled graph is a graph endowed with a function <span class="math notranslate nohighlight">\(\ell : E \rightarrow \mathcal{L}\)</span> that assigns labels to the edges of the graph from a label set <span class="math notranslate nohighlight">\(\mathcal{L}\)</span>. Note that <span class="math notranslate nohighlight">\(E\)</span> is the set of edges of the graph. The Figure below shows an edge-labeled graph with three nodes and two edges. The edges are labeled with symbols from <span class="math notranslate nohighlight">\(\mathcal{L} = \{ a, b \}\)</span>.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/example_graph_edge_labeled.svg"><img alt="../_images/example_graph_edge_labeled.svg" height="952" src="../_images/example_graph_edge_labeled.svg" width="1432" /></a>
</div>
<ul>
<li><div class="line-block">
<div class="line">A dictionary keyed by edges to their labels.</div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">edges</span> <span class="o">=</span> <span class="p">{(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span> <span class="mi">1</span><span class="p">}</span>
<span class="n">edge_labels</span> <span class="o">=</span> <span class="p">{(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span> <span class="s1">&#39;b&#39;</span><span class="p">}</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">edge_labels</span><span class="o">=</span><span class="n">edge_labels</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><div class="line-block">
<div class="line">A dictionary keyed by edge indices (i.e., <span class="math notranslate nohighlight">\(0,\ldots,(|E|-1)\)</span>) to their labels.</div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">adj</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="n">edge_labels</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;b&#39;</span><span class="p">}</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">edge_labels</span><span class="o">=</span><span class="n">edge_labels</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
<p>An edge-attributed graph is a graph endowed with a function <span class="math notranslate nohighlight">\(f : E \rightarrow \mathbb{R}^d\)</span> that assigns real-valued vectors to the edges of the graph. The following Figure illustrates an edge-attributed graph with three nodes and two edges.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/example_graph_edge_attributed.svg"><img alt="../_images/example_graph_edge_attributed.svg" height="1332" src="../_images/example_graph_edge_attributed.svg" width="3427" /></a>
</div>
<ul>
<li><div class="line-block">
<div class="line">A dictionary keyed by edges to their attributes.</div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">edges</span> <span class="o">=</span> <span class="p">{(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span> <span class="mi">1</span><span class="p">}</span>
<span class="n">edge_attributes</span> <span class="o">=</span> <span class="p">{(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">1.3</span><span class="p">],</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span> <span class="p">[</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">1.3</span><span class="p">],</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span> <span class="p">[</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">]}</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">edge_labels</span><span class="o">=</span><span class="n">edge_attributes</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><div class="line-block">
<div class="line">A dictionary keyed by edge indices (i.e., <span class="math notranslate nohighlight">\(0,\ldots,(|E|-1)\)</span>) to their attributes.</div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">adj</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="n">edge_attributes</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">1.3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">]}</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">edge_labels</span><span class="o">=</span><span class="n">edge_attributes</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
<p>Note that not all kernels can take into account node/edge labels and node/edge attributes. To find the type of graphs that each kernel expects as input, see <a class="reference internal" href="../graph_kernel.html#graph-kernel"><span class="std std-ref">GraphKernel (class)</span></a>.</p>
<p>In general the structure of a graph-like iterable (the input template of all kernels) is organized in the following picture:</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/graph_schema.svg"><img alt="../_images/graph_schema.svg" height="423" src="../_images/graph_schema.svg" width="647" /></a>
</div>
</div>
<div class="section" id="initializing-a-graph-kernel">
<h2>Initializing a Graph Kernel<a class="headerlink" href="#initializing-a-graph-kernel" title="Permalink to this headline">¶</a></h2>
<p>One of the most popular graph kernels is the <em>shortest path kernel</em> which counts the number of shortest paths of equal length in two graphs <a class="bibtex reference internal" href="../kernels/shortest_path.html#borgwardt2005shortest" id="id1">[BK05]</a>.</p>
<p>After installing the library (see <a class="reference internal" href="installation.html#installation"><span class="std std-ref">Installing GraKeL</span></a>), we can initialize an instance of the shortest path kernel as follows:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">grakel</span> <span class="kn">import</span> <span class="n">GraphKernel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sp_kernel</span> <span class="o">=</span> <span class="n">GraphKernel</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="s2">&quot;shortest_path&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Alternatively, we can directly create an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">grakel.kernels.ShortestPath</span></code> object as follows:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">grakel.kernels</span> <span class="kn">import</span> <span class="n">ShortestPath</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sp_kernel</span> <span class="o">=</span> <span class="n">ShortestPath</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="initializing-a-framework">
<h2>Initializing a Framework<a class="headerlink" href="#initializing-a-framework" title="Permalink to this headline">¶</a></h2>
<p>Research in the field of graph kernels has not only focused on designing new kernels between graphs, but also on frameworks and approaches that can be applied to existing graph kernels and increase their performance. The most popular of all frameworks is perhaps the <em>Weisfeiler-Lehman framework</em> <a class="bibtex reference internal" href="../kernels/weisfeiler_lehman.html#shervashidze2011weisfeiler" id="id2">[SSVL+11]</a>. The Weisfeiler-Lehman framework works on top of some graph kernel, known as the <em>base kernel</em>. We can initialize the well-known Weisfeiler-Lehman subtree kernel (Weisfeiler-Lehman framework on top of the <em>vertex histogram</em> kernel) as follows:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">grakel.kernels</span> <span class="kn">import</span> <span class="n">WeisfeilerLehman</span><span class="p">,</span> <span class="n">VertexHistogram</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wl_kernel</span> <span class="o">=</span> <span class="n">WeisfeilerLehman</span><span class="p">(</span><span class="n">base_graph_kernel</span><span class="o">=</span><span class="n">VertexHistogram</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="computing-the-kernel-between-two-graphs">
<h2>Computing the Kernel Between Two Graphs<a class="headerlink" href="#computing-the-kernel-between-two-graphs" title="Permalink to this headline">¶</a></h2>
<p>Let us consider a toy example, where we compute some graph kernel between two molecules: (1) water <span class="math notranslate nohighlight">\(\mathbf{H}_{2}\mathbf{O}\)</span> and (2) hydronium <span class="math notranslate nohighlight">\(\mathbf{H}_{3}\mathbf{O}^{+}\)</span>, an ion of water produced by protonation.</p>
<p>We first create the graph representations of the two molecules:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">grakel</span> <span class="kn">import</span> <span class="n">Graph</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H2O_adjacency</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H2O_node_labels</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s1">&#39;O&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H2O</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">initialization_object</span><span class="o">=</span><span class="n">H2O_adjacency</span><span class="p">,</span> <span class="n">node_labels</span><span class="o">=</span><span class="n">H2O_node_labels</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H3O_adjacency</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H3O_node_labels</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s1">&#39;O&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="s1">&#39;H&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H3O</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="n">initialization_object</span><span class="o">=</span><span class="n">H3O_adjacency</span><span class="p">,</span> <span class="n">node_labels</span><span class="o">=</span><span class="n">H3O_node_labels</span><span class="p">)</span>
</pre></div>
</div>
<p>We employ the shortest path kernel and we first compute the kernel value between the graph representation of water and itself:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sp_kernel</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">([</span><span class="n">H2O</span><span class="p">])</span>
<span class="go">array([[12.]])</span>
</pre></div>
</div>
<p>Next, we calculate the kernel value between the graph representation of water and that of hydronium:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sp_kernel</span><span class="o">.</span><span class="n">transform</span><span class="p">([</span><span class="n">H3O</span><span class="p">])</span>
<span class="go">array([[24.]])</span>
</pre></div>
</div>
<p>The above result suggests that the water molecule is more similar to hydronium than to itself. This is because the kernel values are not normalized. To apply normalization, we can set the corresponding attribute to <code class="code docutils literal notranslate"><span class="pre">True</span></code> when initializing the graph kernel:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sp_kernel</span> <span class="o">=</span> <span class="n">ShortestPath</span><span class="p">(</span><span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sp_kernel</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">([</span><span class="n">H2O</span><span class="p">])</span>
<span class="go">array([[1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sp_kernel</span><span class="o">.</span><span class="n">transform</span><span class="p">([</span><span class="n">H3O</span><span class="p">])</span>
<span class="go">array([[0.94280904]])</span>
</pre></div>
</div>
</div>
<div class="section" id="performing-graph-classification">
<h2>Performing Graph Classification<a class="headerlink" href="#performing-graph-classification" title="Permalink to this headline">¶</a></h2>
<p>The last part of this short introduction demonstrates how graph kernels can be used to perform graph classification.</p>
<p>We will experiment with the MUTAG dataset, one of the most popular graph classification datasets. The dataset contains 188 mutagenic aromatic and heteroaromatic nitro compounds, and the task is to predict whether or not each chemical compound has mutagenic effect on the Gram-negative bacterium Salmonella typhimurium.</p>
<p>We can use the <a class="reference internal" href="../generated/grakel.datasets.fetch_dataset.html#grakel.datasets.fetch_dataset" title="grakel.datasets.fetch_dataset"><code class="xref py py-class docutils literal notranslate"><span class="pre">grakel.datasets.fetch_dataset</span></code></a> function of GraKeL to load MUTAG or any other graph classification dataset from <a class="reference external" href="http://graphkernels.cs.tu-dortmund.de/">http://graphkernels.cs.tu-dortmund.de/</a>. The function automatically downloads the raw files of the dataset and returns an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">sklearn.utils.Bunch</span></code> whose attribute <code class="code docutils literal notranslate"><span class="pre">data</span></code> contains the graphs and its attribute <code class="code docutils literal notranslate"><span class="pre">target</span></code> the classification labels.</p>
<p>We can load the MUTAG dataset as follows:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">grakel.datasets</span> <span class="kn">import</span> <span class="n">fetch_dataset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MUTAG</span> <span class="o">=</span> <span class="n">fetch_dataset</span><span class="p">(</span><span class="s2">&quot;MUTAG&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">MUTAG</span><span class="o">.</span><span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">MUTAG</span><span class="o">.</span><span class="n">target</span>
</pre></div>
</div>
<p>Next, we will initialize a Weisfeiler-Lehman subtree kernel:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">grakel.kernels</span> <span class="kn">import</span> <span class="n">WeisfeilerLehman</span><span class="p">,</span> <span class="n">VertexHistogram</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wl_kernel</span> <span class="o">=</span> <span class="n">WeisfeilerLehman</span><span class="p">(</span><span class="n">n_iter</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">base_graph_kernel</span><span class="o">=</span><span class="n">VertexHistogram</span><span class="p">)</span>
</pre></div>
</div>
<p>To perform classification, it is necessary to split the dataset into a training and a test set. We can use the <code class="code docutils literal notranslate"><span class="pre">train_test_split</span></code> function of scikit-learn as follows:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G_train</span><span class="p">,</span> <span class="n">G_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
</pre></div>
</div>
<p>In order to perform classification, one generally needs to generate two matrices: A symmetric matrix <span class="math notranslate nohighlight">\(\mathbf{K}_{train}\)</span> which contains the kernel values for all pairs of training graphs, and a second matrix <span class="math notranslate nohighlight">\(\mathbf{K}_{test}\)</span> which stores the kernel values between the graphs of the test set and those of the training set. The first matrix can be generated as follows:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">K_train</span> <span class="o">=</span> <span class="n">wl_kernel</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">G_train</span><span class="p">)</span>
</pre></div>
</div>
<p>Then, we can generate the second matrix using the following code:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">K_test</span> <span class="o">=</span> <span class="n">wl_kernel</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">G_test</span><span class="p">)</span>
</pre></div>
</div>
<p>Next, we employ the SVM classifier and use it to perform classification. We train the classifier on the training set and then, make predictions for the graphs of the test set.</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">SVC</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">SVC</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="s1">&#39;precomputed&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">K_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="go">SVC(kernel=&#39;precomputed&#39;)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">K_test</span><span class="p">)</span>
</pre></div>
</div>
<p>Finally, we compute and print the classification accuracy as follows:</p>
<div class="highlight-pycon3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">accuracy_score</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%2.2f</span><span class="s2"> </span><span class="si">%%</span><span class="s2">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">accuracy_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span><span class="p">)))</span>
<span class="go">84.00 %</span>
</pre></div>
</div>
</div>
<div class="section" id="bibliography">
<h2>Bibliography<a class="headerlink" href="#bibliography" title="Permalink to this headline">¶</a></h2>
<p id="bibtex-bibliography-documentation/introduction-0"><dl class="citation">
<dt class="bibtex label" id="borgwardt2005shortest"><span class="brackets"><a class="fn-backref" href="#id1">BK05</a></span></dt>
<dd><p>Karsten M. Borgwardt and Hans-Peter Kriegel. Shortest-path kernels on graphs. In <em>Proceedings of the 5th International Conference on Data Mining</em>, 74–81. 2005.</p>
</dd>
<dt class="bibtex label" id="shervashidze2011weisfeiler"><span class="brackets"><a class="fn-backref" href="#id2">SSVL+11</a></span></dt>
<dd><p>Nino Shervashidze, Pascal Schweitzer, Erik Jan van Van Leeuwen, Kurt Mehlhorn, and Karsten M. Borgwardt. Weisfeiler-Lehman Graph Kernels. <em>Journal of Machine Learning Research</em>, 12:2539–2561, 2011.</p>
</dd>
</dl>
</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="core_concepts.html" class="btn btn-neutral float-right" title="Core Concepts" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="installation.html" class="btn btn-neutral float-left" title="Installing GraKeL" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2019, DaSciM (BSD License).

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>